{
    "discoveryDefinition": {
        "sourceConfigIdentityFields": [
            "dbPath"
        ], 
        "sourceConfigNameField": "dbPath", 
        "repositoryIdentityFields": [
            "postgresInstallPath", 
            "postgresShellPath"
        ], 
        "repositorySchema": {
            "additionalProperties": false, 
            "type": "object", 
            "properties": {
                "repositoryName": {
                    "prettyName": "Repository Name", 
                    "type": "string", 
                    "description": "Pretty name of this repository"
                }, 
                "version": {
                    "prettyName": "Version", 
                    "type": "string", 
                    "description": "Postgres Version"
                }, 
                "postgresInstallPath": {
                    "prettyName": "Postgres Install Path", 
                    "type": "string", 
                    "description": "Path to Postgres binaries"
                }, 
                "postgresShellPath": {
                    "prettyName": "Postgres Shell Path", 
                    "type": "string", 
                    "description": "Path to Postgres Shell"
                }
            }
        }, 
        "sourceConfigDiscovery": "--\n-- Copyright (c) 2018, 2019 by Delphix. All rights reserved.\n--\n\nreturn {}\n", 
        "manualSourceConfigDiscovery": true, 
        "repositoryDiscovery": "--\n-- Copyright (c) 2018, 2019 by Delphix. All rights reserved.\n--\nenv={\n        DLPX_PLUGIN_WORKFLOW=\"discovery/repoDiscovery.lua\",\n        DELPHIX_BIN=remote.binaryPath,\n        DLPX_LIBRARY_SOURCE=resources[\"library.sh\"]\n}\n\nreturn RunBash {\n  command = resources[\"repoDiscovery.sh\"],\n  environment = remote.environment,\n  user = remote.environmentUser,\n  host = remote.host,\n  variables = env,\n  outputSchema = {\n    type = \"array\",\n    items = {\n      type=\"object\",\n      additionalProperties = false,\n      properties = {\n        postgresInstallPath  = { type=\"string\" },\n        postgresShellPath  = { type=\"string\" },\n        version      = { type=\"string\" },\n        repositoryName   = { type=\"string\" }\n      }\n    }\n  }\n}\n", 
        "repositoryNameField": "repositoryName", 
        "type": "ToolkitDiscoveryDefinition", 
        "sourceConfigSchema": {
            "additionalProperties": false, 
            "required": [
                "dbPath"
            ], 
            "type": "object", 
            "properties": {
                "dbPath": {
                    "prettyName": "Source Config Name", 
                    "type": "string", 
                    "description": "Source Config Name"
                }
            }
        }
    }, 
    "snapshotSchema": {
        "additionalProperties": false, 
        "type": "object", 
        "properties": {
            "timeStamp": {
                "prettyName": "Snapshot Timestamp", 
                "type": "string", 
                "description": "Snapshot Timestamp"
            }, 
            "snapPort": {
                "prettyName": "Snapshot Port", 
                "type": "string", 
                "description": "Snapshot Port"
            }, 
            "version": {
                "prettyName": "Version", 
                "type": "string", 
                "description": "Postgres Version"
            }, 
            "snapPath": {
                "prettyName": "Snapshot Path", 
                "type": "string", 
                "description": "Snapshot Path"
            }, 
            "snapshotId": {
                "prettyName": "Snapshot ID", 
                "type": "string", 
                "description": "A unique ID for this snapshot"
            }, 
            "snapHost": {
                "prettyName": "Snapshot Host", 
                "type": "string", 
                "description": "Snapshot Host"
            }
        }
    }, 
    "name": "postgres", 
    "language": "LUA", 
    "hostTypes": [
        "UNIX"
    ], 
    "virtualSourceDefinition": {
        "status": "--\n-- Copyright (c) 2018, 2019 by Delphix. All rights reserved.\n--\nenv = {\n   DLPX_LIBRARY_SOURCE\t= resources[\"library.sh\"],\n   DLPX_DATA_DIRECTORY = source.dataDirectory,\n   DELPHIX_BIN = remote.binaryPath,\n   DLPX_PLUGIN_WORKFLOW = \"virtual/status.lua\",\n   PG_VIRTUAL_PORT = parameters.postgresPort,\n   POSTGRESQL_STATUS_TYPE = 'virtual'\n}\n\nreturn RunBash {\n  command      = resources[\"status.sh\"],\n  environment  = source.environment,\n  user         = source.environmentUser,\n  host         = source.host,\n  variables    = env,\n  outputSchema = { type = 'string' }\n}\n", 
        "configure": "--\n-- Copyright (c) 2018, 2019 by Delphix. All rights reserved.\n--\n\nload(resources[\"lib.lua\"])()\n\nenv = {\n   DLPX_PLUGIN_WORKFLOW = \"virtual/configure.lua\",\n   DELPHIX_BIN           = remote.binaryPath,\n   DLPX_LIBRARY_SOURCE   = resources[\"library.sh\"],\n   DLPX_DATA_DIRECTORY\t = source.dataDirectory,\n   PG_VIRTUAL_PORT\t = parameters.postgresPort,\n   PG_INSTALL_PATH       = repository.postgresInstallPath,\n   PG_SHELL_PATH         = repository.postgresShellPath,\n   CONFIG_PARAMS_STG     = getPropValString(parameters.configSettingsStg),\n   PG_SNAPSHOT_METADATA  = snapshotJson,\n   PG_VERSION            = repository.version\n}\n\nprovisionOutput = RunBash {\n   command     = resources[\"provision.sh\"],\n   environment = source.environment,\n   user        = source.environmentUser,\n   host        = source.host,\n   variables   = env,\n   outputSchema = { type = \"object\" }\n}\n\nif provisionOutput.errorType == \"ERROR\" then\n   errorMessage = messages[provisionOutput.messageID]\n   if provisionOutput.allParams == \"None\" then\n      Fail(errorMessage())\n   else\n      Fail(errorMessage(provisionOutput.allParams.param1))\n   end\nend\n\nstartVirtualOutput = RunBash {\n   command         = resources[\"startVirtual.sh\"],\n   environment     = source.environment,\n   user            = source.environmentUser,\n   host            = source.host,\n   variables       = env,\n   outputSchema = { type = \"object\" }\n}\n\nif startVirtualOutput.errorType == \"ERROR\" then\n   errorMessage = messages[startVirtualOutput.messageID]\n   if startVirtualOutput.allParams == \"None\" then\n      Fail(errorMessage())\n   else\n      Fail(errorMessage(startVirtualOutput.allParams.param1))\n   end\nend\n\nreturn {\n   dbPath = provisionOutput.prettyName\n}\n", 
        "parameters": {
            "additionalProperties": false, 
            "ordering": [
                "postgresPort", 
                "configSettingsStg"
            ], 
            "required": [
                "postgresPort"
            ], 
            "type": "object", 
            "properties": {
                "configSettingsStg": {
                    "items": {
                        "ordering": [
                            "propertyName", 
                            "value"
                        ], 
                        "required": [
                            "propertyName", 
                            "value"
                        ], 
                        "type": "object", 
                        "properties": {
                            "propertyName": {
                                "pattern": "^$|^[_a-zA-Z0-9]*$", 
                                "prettyName": "Property Name", 
                                "type": "string", 
                                "maxLength": 40
                            }, 
                            "value": {
                                "pattern": "^$|^[/_.*a-zA-Z0-9]*$", 
                                "prettyName": "Value", 
                                "type": "string", 
                                "maxLength": 40
                            }
                        }
                    }, 
                    "prettyName": "Config Settings", 
                    "type": "array", 
                    "description": "Custom Database-Level config settings"
                }, 
                "postgresPort": {
                    "default": 5434, 
                    "prettyName": "Virtual Postgres Port Number", 
                    "type": "integer", 
                    "description": "Virtual Postgres Port Number"
                }
            }
        }, 
        "stop": "--\n-- Copyright (c) 2018, 2019 by Delphix. All rights reserved.\n--\n\nenv = {\n   DLPX_PLUGIN_WORKFLOW = \"virtual/stop.lua\",\n   DELPHIX_BIN           = remote.binaryPath,\n   DLPX_LIBRARY_SOURCE   = resources[\"library.sh\"],\n   PG_VIRTUAL_PORT       = parameters.postgresPort,\n   DLPX_DATA_DIRECTORY   = source.dataDirectory\n}\n\nstopVirtualOutput = RunBash{\n   command     = resources[\"stopVirtual.sh\"],\n   environment = source.environment,\n   user        = source.environmentUser,\n   host        = source.host,\n   variables   = env,\n   outputSchema = { type = \"object\" }\n}\n\nif stopVirtualOutput.errorType == \"ERROR\" then\n   errorMessage = messages[stopVirtualOutput.messageID]\n   if stopVirtualOutput.allParams == \"None\" then\n      Fail(errorMessage())\n   else\n      Fail(errorMessage(stopVirtualOutput.allParams.param1, stopVirtualOutput.allParams.param2))\n   end\nend\n", 
        "start": "--\n-- Copyright (c) 2018, 2019 by Delphix. All rights reserved.\n--\n\nenv = {\n   DLPX_PLUGIN_WORKFLOW = \"virtual/start.lua\",\n   DELPHIX_BIN           = remote.binaryPath,\n   DLPX_LIBRARY_SOURCE   = resources[\"library.sh\"],\n   DLPX_DATA_DIRECTORY   = source.dataDirectory,\n   PG_VIRTUAL_PORT       = parameters.postgresPort,\n   PG_INSTALL_PATH       = repository.postgresInstallPath\n}\n\nstartVirtualOutput = RunBash {\n   command         = resources[\"startVirtual.sh\"],\n   environment     = source.environment,\n   user            = source.environmentUser,\n   host            = source.host,\n   variables       = env,\n   outputSchema = { type = \"object\" }\n}\n\nif startVirtualOutput.errorType == \"ERROR\" then\n   errorMessage = messages[startVirtualOutput.messageID]\n   if startVirtualOutput.allParams == \"None\" then\n      Fail(errorMessage())\n   else\n      Fail(errorMessage(startVirtualOutput.allParams.param1))\n   end\nend\n", 
        "unconfigure": "--\n-- Copyright (c) 2018, 2019 by Delphix. All rights reserved.\n--\n\nenv = {\n   DLPX_PLUGIN_WORKFLOW = \"virtual/unconfigure.lua\",\n   DELPHIX_BIN           = remote.binaryPath,\n   DLPX_LIBRARY_SOURCE   = resources[\"library.sh\"],\n   PG_VIRTUAL_PORT       = parameters.postgresPort,\n   DLPX_DATA_DIRECTORY   = source.dataDirectory\n}\n\nstopVirtualOutput = RunBash{\n   command     = resources[\"stopVirtual.sh\"],\n   environment = source.environment,\n   user        = source.environmentUser,\n   host        = source.host,\n   variables   = env,\n      outputSchema = { type = \"object\" }\n}\n\nif stopVirtualOutput.errorType == \"ERROR\" then\n   errorMessage = messages[stopVirtualOutput.messageID]\n   if stopVirtualOutput.allParams == \"None\" then\n      Fail(errorMessage())\n   else\n      Fail(errorMessage(stopVirtualOutput.allParams.param1, stopVirtualOutput.allParams.param2))\n   end\nend\n", 
        "reconfigure": "--\n-- Copyright (c) 2018, 2019 by Delphix. All rights reserved.\n--\n\nload(resources[\"lib.lua\"])()\n\nenv = {\n   DLPX_PLUGIN_WORKFLOW = \"virtual/reconfigure.lua\",\n   DELPHIX_BIN           = remote.binaryPath,\n   DLPX_LIBRARY_SOURCE   = resources[\"library.sh\"],\n   DLPX_DATA_DIRECTORY   = source.dataDirectory,\n   PG_VIRTUAL_PORT       = parameters.postgresPort,\n   PG_INSTALL_PATH       = repository.postgresInstallPath,\n   CONFIG_PARAMS_STG     = getPropValString(parameters.configSettingsStg)\n}\n\nreconfigOutput = RunBash{\n   command     = resources[\"reconfigure.sh\"],\n   environment = source.environment,\n   user        = source.environmentUser,\n   host        = source.host,\n   variables   = env,\n   outputSchema = { type = \"object\" }\n}\n\nif reconfigOutput.errorType == \"ERROR\" then\n   errorMessage = messages[reconfigOutput.messageID]\n   if reconfigOutput.allParams == \"None\" then\n      Fail(errorMessage())\n   else\n      Fail(errorMessage(reconfigOutput.allParams.param1))\n   end\nend\n\ncustomConfigParamOutput = RunBash {\n   command     = resources[\"customConfigParam.sh\"],\n   environment = source.environment,\n   user        = source.environmentUser,\n   host        = source.host,\n   variables   = env,\n   outputSchema = { type = \"object\" }\n}\n\nif customConfigParamOutput.errorType == \"ERROR\" then\n   errorMessage = messages[customConfigParamOutput.messageID]\n   if customConfigParamOutput.allParams == \"None\" then\n      Fail(errorMessage())\n   else\n      Fail(errorMessage(customConfigParamOutput.allParams.param1))\n   end\nend\n\nstartVirtualOutput = RunBash {\n   command         = resources[\"startVirtual.sh\"],\n   environment     = source.environment,\n   user            = source.environmentUser,\n   host            = source.host,\n   variables       = env,\n   outputSchema = { type = \"object\" }\n}\n\nif startVirtualOutput.errorType == \"ERROR\" then\n   errorMessage = messages[startVirtualOutput.messageID]\n   if startVirtualOutput.allParams == \"None\" then\n      Fail(errorMessage())\n   else\n      Fail(errorMessage(startVirtualOutput.allParams.param1))\n   end\nend\n\nreturn {\n    dbPath = reconfigOutput.prettyName\n}\n", 
        "preSnapshot": "--\n-- Copyright (c) 2018, 2019 by Delphix. All rights reserved.\n--\n\n-- Snapshotting a VDB simply involves a ZFS file system snapshot\n-- of the Delphix Engine mount point for the virtual database.\n-- Hence, the only plugin operation would be to record the\n-- metadata for the corresponding snapshot in recordVirtual.sh\n", 
        "type": "ToolkitVirtualSource", 
        "postSnapshot": "--\n-- Copyright (c) 2018, 2019 by Delphix. All rights reserved.\n--\n\nenv = {\n   DLPX_PLUGIN_WORKFLOW = \"virtual/postSnapshot.lua\",\n   DELPHIX_BIN           = remote.binaryPath,\n   DLPX_LIBRARY_SOURCE   = resources[\"library.sh\"],\n   DLPX_DATA_DIRECTORY   = source.dataDirectory,\n   PG_VIRTUAL_PORT       = parameters.postgresPort,\n   PG_INSTALL_PATH       = repository.postgresInstallPath,\n   PG_VERSION            = repository.version\n}\n\nreturn RunBash{\n   command     = resources[\"recordVirtual.sh\"],\n   environment = source.environment,\n   user        = source.environmentUser,\n   host        = source.host,\n   variables   = env,\n   outputSchema = {\n      type = \"object\",\n      additionalProperties = false,\n      properties = {\n         snapshotId = { type=\"string\" },\n         timeStamp = { type=\"string\" },\n         snapPort = { type=\"string\" },\n         snapHost = { type=\"string\" },\n         snapPath = { type=\"string\" },\n         version = { type=\"string\" }\n      }\n   }\n}\n"
    }, 
    "messages": [
        {
            "localeName": "en-us", 
            "type": "ToolkitLocale", 
            "messages": {
                "newTableSpaceFound": "A new tablespace is created on source. Please resynchronize dSource.", 
                "unzipUtilityNotFound": "unzip utility not found on host {0}. Please install it and then try again.", 
                "portNotClosed": "Error: Port {0} failed to close on stopping the database. The port is occupied by PIDs: {1}. Please check and try again.", 
                "dSourceNotInSync": "Please provide either wal log path or allow the dSource to be in sync through streaming replication.", 
                "dbDown": "The Database instance is down on host {0}.", 
                "walLogChainBreakDetected": "Error : {0}", 
                "dataDirMissing": "Data directory : {0} not found on host.", 
                "connectivityIssue": "Unable to connect to database server. Connection refused.", 
                "versionMismatch": "Postgres version : {0} does not match with version found on host.", 
                "invalidParamInConfigStg": "Parameter provided by the user does not exist in postgresql.conf file and is invalid : \"{0}\". Please provide the correct parameter and try again.", 
                "invalidBackupFile": "Backup tar file provided by the user is not valid. File : {0}. Please provide the correct file and try again.", 
                "parametersNotProvided": "Allow the dSource to be in sync through streaming replication is true but it's dependent delphix_initiated parameters are not provided. Please provide the parameters and try again.", 
                "directoryNotFound": "Provided path does not exist. Path: {0}. Please provide a valid path.", 
                "invalidZipFile": "Backup provided in the zip file {0} is not valid. Please provide the correct file and try again.", 
                "errorCreatingFile": "Error occured while creating file on host {0}.", 
                "pgBasebackupFail": "pg_basebackup failed on host. Error : {0}.", 
                "dirMissing": "Delphix mount directory : {0} missing on host.", 
                "installDirMissing": "Install directory not found while starting database on host {0}.", 
                "portInUse": "Provided port : {0} is already in use on host. Please provide a different port.", 
                "backupFileNotFound": "PostgreSQL backup files are not found on specified path on host {0}. Backup file with file format PostgreSQL_TYYYYMMDD.zip should exist on the path.", 
                "allProcessParamsAreSupplied": "We can perform linking through only one way either through external_backup or by delphix_initiated process. Please provide parameters of only one of the process.", 
                "invalidPortRange": "Input port : {0} is invalid. Please provide a valid port number.", 
                "errorCopyingFile": "Error occured while copying file in data directory on host {0}."
            }
        }
    ], 
    "linkedSourceDefinition": {
        "status": "--\n-- Copyright (c) 2018, 2019 by Delphix. All rights reserved.\n--\nenv = {\n   DLPX_PLUGIN_WORKFLOW = \"staged/status.lua\",\n   DLPX_DATA_DIRECTORY = source.dataDirectory,\n   DELPHIX_BIN = remote.binaryPath,\n   DLPX_LIBRARY_SOURCE = resources[\"library.sh\"],\n   PG_STAGED_PORT = parameters.postgresPort,\n   POSTGRESQL_STATUS_TYPE = 'staged'\n}\n\nreturn RunBash {\n  command      = resources[\"status.sh\"],\n  environment  = source.stagingEnvironment,\n  user         = source.stagingEnvironmentUser,\n  host         = source.stagingHost,\n  variables    = env,\n  outputSchema = { type = 'string' }\n}\n", 
        "parameters": {
            "additionalProperties": false, 
            "ordering": [
                "externalBackup", 
                "keepStagingInSync", 
                "delphixInitiatedBackupFlag", 
                "delphixInitiatedBackup", 
                "postgresPort", 
                "configSettingsStg"
            ], 
            "required": [
                "postgresPort"
            ], 
            "type": "object", 
            "properties": {
                "externalBackup": {
                    "items": {
                        "ordering": [
                            "backupPath", 
                            "walLogPath"
                        ], 
                        "additionalProperties": false, 
                        "required": [
                            "backupPath"
                        ], 
                        "type": "object", 
                        "properties": {
                            "walLogPath": {
                                "prettyName": "PostgreSQL Backup WAL Log Files Path", 
                                "type": "string", 
                                "description": "Allow the dSource to restore the WAL log files from this path"
                            }, 
                            "backupPath": {
                                "prettyName": "PostgreSQL Backup Files Path", 
                                "type": "string", 
                                "description": "PostgreSQL Backup Files Path"
                            }
                        }
                    }, 
                    "prettyName": "External Backup", 
                    "type": "array", 
                    "description": "dSource Creation through external backup", 
                    "maxItems": 1
                }, 
                "delphixInitiatedBackupFlag": {
                    "default": false, 
                    "prettyName": "Delphix Initiated Backup Flag", 
                    "type": "boolean", 
                    "description": "Allow Delphix to initiate the backups from source database. \"Delphix Initiated Backup\" parameters are mandatory for ingestion."
                }, 
                "keepStagingInSync": {
                    "default": false, 
                    "prettyName": "Allow the dSource to be in sync through streaming replication if WalLogs are not provided.", 
                    "type": "boolean", 
                    "description": "Allow the dSource to be in sync with Source through streaming replication if WalLogs are not provided. \"Delphix Initiated Backup\" parameters are mandatory for this."
                }, 
                "configSettingsStg": {
                    "items": {
                        "ordering": [
                            "propertyName", 
                            "value"
                        ], 
                        "required": [
                            "propertyName", 
                            "value"
                        ], 
                        "type": "object", 
                        "properties": {
                            "propertyName": {
                                "pattern": "^$|^[_a-zA-Z0-9]*$", 
                                "prettyName": "Property Name", 
                                "type": "string", 
                                "maxLength": 40
                            }, 
                            "value": {
                                "pattern": "^$|^[/_.*a-zA-Z0-9]*$", 
                                "prettyName": "Value", 
                                "type": "string", 
                                "maxLength": 40
                            }
                        }
                    }, 
                    "prettyName": "Config Settings", 
                    "type": "array", 
                    "description": "Custom Database-Level config settings"
                }, 
                "delphixInitiatedBackup": {
                    "items": {
                        "ordering": [
                            "userName", 
                            "userPass", 
                            "sourceHostAddress", 
                            "postgresSourcePort"
                        ], 
                        "additionalProperties": false, 
                        "required": [
                            "userName", 
                            "userPass", 
                            "sourceHostAddress", 
                            "postgresSourcePort"
                        ], 
                        "type": "object", 
                        "properties": {
                            "userName": {
                                "default": "delphix", 
                                "prettyName": "PostgresDB Replication User", 
                                "type": "string", 
                                "description": "Replication User for postgres database"
                            }, 
                            "userPass": {
                                "prettyName": "PostgresDB Replication User Password", 
                                "type": "string", 
                                "description": "Replication password for postgres database", 
                                "format": "password"
                            }, 
                            "postgresSourcePort": {
                                "default": 5432, 
                                "prettyName": "Source Instance Port Number", 
                                "type": "integer", 
                                "description": "Port number for postgres source database"
                            }, 
                            "sourceHostAddress": {
                                "prettyName": "Source Host Address", 
                                "type": "string", 
                                "description": "Source Host Address"
                            }
                        }
                    }, 
                    "prettyName": "Delphix Initiated Backup/External Backup - Streaming Replication", 
                    "type": "array", 
                    "description": "List of parameters for Delphix initiated backup and external backup with streaming replication", 
                    "maxItems": 1
                }, 
                "postgresPort": {
                    "default": 5433, 
                    "prettyName": "Staging Instance Port Number", 
                    "type": "integer", 
                    "description": "Port number for postgres staging database"
                }
            }
        }, 
        "worker": "", 
        "stopStaging": "--\n-- Copyright (c) 2018, 2019 by Delphix. All rights reserved.\n--\n\nenv = {\n   DLPX_DATA_DIRECTORY=source.dataDirectory,\n   DELPHIX_BIN=remote.binaryPath,\n   DLPX_PLUGIN_WORKFLOW=\"staged/stopStaging.lua\",\n   DLPX_LIBRARY_SOURCE=resources[\"library.sh\"],\n   PG_STAGED_PORT=parameters.postgresPort\n}\n\nstopStagingOutput = RunBash{\n   command     = resources[\"stopStaging.sh\"],\n   environment = source.stagingEnvironment,\n   user        = source.stagingEnvironmentUser,\n   host        = source.stagingHost,\n   variables   = env,\n   outputSchema = { type = \"object\" }\n}\n\nif stopStagingOutput.errorType == \"ERROR\" then\n   errorMessage = messages[stopStagingOutput.messageID]\n   if stopStagingOutput.allParams == \"None\" then\n      Fail(errorMessage())\n   else\n      Fail(errorMessage(stopStagingOutput.allParams.param1, stopStagingOutput.allParams.param2))\n   end\nend\n", 
        "startStaging": "--\n-- Copyright (c) 2018, 2019 by Delphix. All rights reserved.\n--\n\nload(resources[\"lib.lua\"])()\n\nenv = {\n   DLPX_DATA_DIRECTORY   = source.dataDirectory,\n   DELPHIX_BIN           = remote.binaryPath,\n   DLPX_PLUGIN_WORKFLOW = \"staged/startStaging.lua\",\n   DLPX_LIBRARY_SOURCE   = resources[\"library.sh\"],\n   PG_STAGED_PORT        = parameters.postgresPort,\n   PG_INSTALL_PATH       = repository.postgresInstallPath,\n   PG_VERSION            = repository.version,\n   CONFIG_PARAMS_STG     = getPropValString(parameters.configSettingsStg)\n}\n\ncustomConfigParamOutput = RunBash {\n   command     = resources[\"customConfigParam.sh\"],\n   environment = source.stagingEnvironment,\n   user        = source.stagingEnvironmentUser,\n   host        = source.stagingHost,\n   variables   = env,\n   outputSchema = { type = \"object\" }\n}\n\nif customConfigParamOutput.errorType == \"ERROR\" then\n   errorMessage = messages[customConfigParamOutput.messageID]\n   if customConfigParamOutput.allParams == \"None\" then\n      Fail(errorMessage())\n   else\n      Fail(errorMessage(customConfigParamOutput.allParams.param1))\n   end\nend\n\nstartStagingOutput = RunBash {\n   command         = resources[\"startStaging.sh\"],\n   environment     = source.stagingEnvironment,\n   user            = source.stagingEnvironmentUser,\n   host            = source.stagingHost,\n   variables       = env,\n   outputSchema = { type = \"object\" }\n}\n\nif startStagingOutput.errorType == \"ERROR\" then\n   errorMessage = messages[startStagingOutput.messageID]\n   if startStagingOutput.allParams == \"None\" then\n      Fail(errorMessage())\n   else\n      Fail(errorMessage(startStagingOutput.allParams.param1))\n   end\nend\n", 
        "resync": "--\n-- Copyright (c) 2018, 2019 by Delphix. All rights reserved.\n--\n\nload(resources[\"lib.lua\"])()\nbackupPath = \"\"\nwalLogPath = \"\"\nuserName = \"\"\nuserPass = \"\"\nsourceHostAddress = \"\"\npostgresSourcePort = \"\"\n\n--\n-- Extract parameters from External Backup Array\n--\n\nif (#parameters.externalBackup > 0) then\n   backupPath = parameters.externalBackup[1][\"backupPath\"]\n   walLogPath = parameters.externalBackup[1][\"walLogPath\"]\nend\n\n--\n-- Extract parameters from Delphix Initiated Backup Array\n--\n\nif (#parameters.delphixInitiatedBackup > 0) then\n   userName = parameters.delphixInitiatedBackup[1][\"userName\"]\n   userPass = parameters.delphixInitiatedBackup[1][\"userPass\"]\n   sourceHostAddress = parameters.delphixInitiatedBackup[1][\"sourceHostAddress\"]\n   postgresSourcePort = parameters.delphixInitiatedBackup[1][\"postgresSourcePort\"]\nend\n\nenv = {\n   DLPX_PLUGIN_WORKFLOW=\"staged/resync.lua\",\n   DELPHIX_BIN=remote.binaryPath,\n   DLPX_LIBRARY_SOURCE=resources[\"library.sh\"],\n   DLPX_DATA_DIRECTORY=source.dataDirectory,\n   PG_STAGED_PORT=parameters.postgresPort,\n   PG_INSTALL_PATH=repository.postgresInstallPath,\n   PG_VERSION=repository.version,\n   CONFIG_PARAMS_STG=getPropValString(parameters.configSettingsStg),\n   BACKUP_FLAG=parameters.delphixInitiatedBackupFlag,\n   IN_SYNC_FLAG=parameters.keepStagingInSync,\n   PG_BACKUP_PATH = backupPath,\n   WAL_LOG_PATH = walLogPath,\n   PG_REPL_USER = userName,\n   PG_REPL_PASS = userPass,\n   PG_SOURCE_IP = sourceHostAddress,\n   PG_SOURCE_PORT = postgresSourcePort\n}\n\nrestoreOutput = RunBash {\n   command         = resources[\"restore.sh\"],\n   environment     = source.stagingEnvironment,\n   user            = source.stagingEnvironmentUser,\n   host            = source.stagingHost,\n   variables       = env,\n   outputSchema = { type = \"object\" }\n}\n\nif restoreOutput.errorType == \"ERROR\" then\n   errorMessage = messages[restoreOutput.messageID]\n   if restoreOutput.allParams == \"None\" then\n      Fail(errorMessage())\n   else\n      Fail(errorMessage(restoreOutput.allParams.param1))\n   end\nend\n\n\nstartStagingOutput = RunBash {\n   command         = resources[\"startStaging.sh\"],\n   environment     = source.stagingEnvironment,\n   user            = source.stagingEnvironmentUser,\n   host            = source.stagingHost,\n   variables       = env,\n   outputSchema = { type = \"object\" }\n}\n\nif startStagingOutput.errorType == \"ERROR\" then\n   errorMessage = messages[startStagingOutput.messageID]\n   if startStagingOutput.allParams == \"None\" then\n      Fail(errorMessage())\n   else\n      Fail(errorMessage(startStagingOutput.allParams.param1))\n   end\nend\n", 
        "preSnapshot": "--\n-- Copyright (c) 2018, 2019 by Delphix. All rights reserved.\n--\n\nenv = {\n   DLPX_DATA_DIRECTORY   = source.dataDirectory,\n   DELPHIX_BIN           = remote.binaryPath,\n   DLPX_PLUGIN_WORKFLOW = \"staged/preSnapshot.lua\",\n   DLPX_LIBRARY_SOURCE   = resources[\"library.sh\"],\n   PG_STAGED_PORT        = parameters.postgresPort\n}\n\nvalidateOutput  = RunBash {\n    command     = resources[\"validate.sh\"],\n    environment = source.stagingEnvironment,\n    user        = source.stagingEnvironmentUser,\n    host        = source.stagingHost,\n    variables   = env,\n    outputSchema = { type = \"object\" }\n}\n\nif validateOutput.errorType == \"ERROR\" then\n   errorMessage = messages[validateOutput.messageID]\n   if validateOutput.allParams == \"None\" then\n      Fail(errorMessage())\n   else\n      Fail(errorMessage(validateOutput.allParams.param1))\n   end\nend\n\nstopStagingOutput = RunBash{\n   command     = resources[\"stopStaging.sh\"],\n   environment = source.stagingEnvironment,\n   user        = source.stagingEnvironmentUser,\n   host        = source.stagingHost,\n   variables   = env,\n   outputSchema = { type = \"object\" }\n}\n\nif stopStagingOutput.errorType == \"ERROR\" then\n   errorMessage = messages[stopStagingOutput.messageID]\n   if stopStagingOutput.allParams == \"None\" then\n      Fail(errorMessage())\n   else\n      Fail(errorMessage(stopStagingOutput.allParams.param1, stopStagingOutput.allParams.param2))\n   end\nend\n", 
        "type": "ToolkitLinkedStagedSource", 
        "postSnapshot": "--\n-- Copyright (c) 2018, 2019 by Delphix. All rights reserved.\n--\n\nenv = {\n   DLPX_DATA_DIRECTORY=source.dataDirectory,\n   DELPHIX_BIN=remote.binaryPath,\n   DLPX_PLUGIN_WORKFLOW=\"staged/postSnapshot.lua\",\n   DLPX_LIBRARY_SOURCE=resources[\"library.sh\"],\n   PG_STAGED_PORT=parameters.postgresPort,\n   PG_VERSION=repository.version,\n   PG_INSTALL_PATH=repository.postgresInstallPath\n}\n\nstartStagingOutput = RunBash {\n   command              = resources[\"startStaging.sh\"],\n   environment          = source.stagingEnvironment,\n   user                 = source.stagingEnvironmentUser,\n   host                 = source.stagingHost,\n   variables            = env,\n   outputSchema = { type = \"object\" }\n}\n\nif startStagingOutput.errorType == \"ERROR\" then\n   errorMessage = messages[startStagingOutput.messageID]\n   if startStagingOutput.allParams == \"None\" then\n      Fail(errorMessage())\n   else\n      Fail(errorMessage(startStagingOutput.allParams.param1))\n   end\nend\n\nreturn RunBash {\n   command                 = resources[\"recordStaged.sh\"],\n   environment             = source.stagingEnvironment,\n   user                    = source.stagingEnvironmentUser,\n   host                    = source.stagingHost,\n   variables               = env,\n   outputSchema = {\n      type = \"object\",\n      additionalProperties = false,\n      properties = {\n         snapshotId = { type=\"string\" },\n         timeStamp = { type=\"string\" },\n         snapPort = { type=\"string\" },\n         snapHost = { type=\"string\" },\n         snapPath = { type=\"string\" },\n         version = { type=\"string\" }\n      }\n   }\n}\n"
    }, 
    "version": "1.3.0", 
    "buildApi": {
        "micro": 0, 
        "major": 1, 
        "type": "APIVersion", 
        "minor": 10
    }, 
    "upgradeDefinition": {
        "upgradeLinkedSource": "--\n-- Copyright (c) 2019 by Delphix. All rights reserved.\n--\n\n\nreturn parameters\n", 
        "upgradeManualSourceConfig": "--\n-- Copyright (c) 2019 by Delphix. All rights reserved.\n--\n\noldParameters = parameters\n\nnewParameters = {\n   dbPath = oldParameters.prettyName\n}\n\nreturn newParameters\n", 
        "upgradeSnapshot": "--\n-- Copyright (c) 2019 by Delphix. All rights reserved.\n--\n\nreturn snapshot\n\n\n", 
        "upgradeVirtualSource": "--\n-- Copyright (c) 2019 by Delphix. All rights reserved.\n--\n\nreturn parameters\n", 
        "type": "ToolkitUpgradeDefinition", 
        "fromVersion": "1.2.0"
    }, 
    "defaultLocale": "en-us", 
    "prettyName": "PostgresDB", 
    "type": "Toolkit", 
    "resources": {
        "recordStaged.sh": "#\n# Copyright (c) 2018 by Delphix. All rights reserved.\n#\n\n#\n# Program Name ...\n#\nPGM_NAME='recordStaged.sh'\n\n#\n# Load Library ...\n#\neval \"${DLPX_LIBRARY_SOURCE}\"\nlog \"======================================== ${PGM_NAME} Started ========================================\"\n\nPG_STAGED_IP=$(hostname -i)\nID=$$\n\nDT=$(date '+%Y%m%d%H%M%S')\noutputJson='{}'\noutputJson=$($DLPX_BIN_JQ \".snapshotId = \\\"$ID\\\" \" <<< \"$outputJson\")\noutputJson=$($DLPX_BIN_JQ \".timeStamp = \\\"$DT\\\" \" <<< \"$outputJson\")\noutputJson=$($DLPX_BIN_JQ \".snapHost = \\\"$PG_STAGED_IP\\\" \" <<< \"$outputJson\")\noutputJson=$($DLPX_BIN_JQ \".snapPort = \\\"$PG_STAGED_PORT\\\" \" <<< \"$outputJson\")\noutputJson=$($DLPX_BIN_JQ \".snapPath = \\\"$DLPX_DATA_DIRECTORY\\\" \" <<< \"$outputJson\")\noutputJson=$($DLPX_BIN_JQ \".version =\\\"$PG_VERSION\\\" \" <<< \"$outputJson\")\necho \"${outputJson}\" > \"${DLPX_OUTPUT_FILE}\"\nlog \"Output: ${outputJson}\"\n\nlog \"======================================== ${PGM_NAME} Ended ========================================\"\nexit 0\n", 
        "provision.sh": "#\n# Copyright (c) 2018, 2019 by Delphix. All rights reserved.\n#\n# This script is used to create a virtual database.\n#\n\n#\n# Program Name ...\n#\nPGM_NAME='provision.sh'\n\n#\n# Load Library ...\n#\neval \"${DLPX_LIBRARY_SOURCE}\"\nlog \"======================================== ${PGM_NAME} Started ========================================\"\nhostName=$(hostname)\nVERSION=$(echo \"${PG_SNAPSHOT_METADATA}\" | $DLPX_BIN_JQ --raw-output '.version')\n\n##############################################################\n#\n# Target Details ...\n#\nTARGET_PORT=\"${PG_VIRTUAL_PORT}\"\nTARGET_BIN=$(dirname \"${PG_SHELL_PATH}\")\nDLPX_VIRTUAL_DIR=\"${DLPX_DATA_DIRECTORY}\"\nlog \"Virtual Port: ${TARGET_PORT}\"\nlog \"Virtual Path: ${DLPX_VIRTUAL_DIR}\"\n\n##############################################################\n# Validation Checks ...\n\n#\n# Check for the installed version of postgres ...\n#\nif [[ ${VERSION} != ${PG_VERSION} ]]; then\n        errorLog \"Postgres version: ${VERSION} does not match with version found on host\"\n        exitWithError ERROR versionMismatch ${VERSION}\nfi\n\n#\n# Check whether the input port is valid. If not\n# then abort the script with proper message ID.\n#\nportStatus=$(isPortAvailable \"${TARGET_PORT}\")\nlog \"port Status is : $portStatus\"\n\nif [[ \"${portStatus}\" == \"PortNotAvailable\" ]]; then\n        errorLog \"Provided port : ${TARGET_PORT} is already in use. Please provide a different port.\"\n        exitWithError ERROR portInUse \"${TARGET_PORT}\"\nelif [[ \"${portStatus}\" == \"InvaidPortRange\" ]]; then\n        errorLog \"Input port : ${TARGET_PORT} is invalid. Please provide a valid port number.\"\n        exitWithError ERROR invalidPortRange \"${TARGET_PORT}\"\nfi\n\n#\n# Validate Path ...\n#\nif [[ ! -d ${DLPX_VIRTUAL_DIR} ]]; then\n        errorLog \"Delphix mount Directory Missing : ${DLPX_VIRTUAL_DIR}, exiting ...\"\n        exitWithError ERROR dirMissing \"${DLPX_VIRTUAL_DIR}\"\nfi\n\nVDB_DATA_DIR=\"${DLPX_VIRTUAL_DIR}/data\"\n\nlog \"Virtual Data Directory: ${VDB_DATA_DIR}\"\n\n##############################################################\n# Updating the configuration files ...\n\n#\n# Remove the postmaster.pid file ...\n#\nrm -f ${VDB_DATA_DIR}/postmaster.pid\n\n#\n# Make backup copy of source config file ...\n#\nDT=$(date '+%Y%m%d%H%M%S')\ncp ${VDB_DATA_DIR}/postgresql.conf ${VDB_DATA_DIR}/postgresql.conf_${DT}\nerrorCheck ERROR errorCopyingFile ${hostName}\n\n#\n# Temporary Config File ...\n#\nTMPFILE=\"tmp.conf_${DT}\"\ncp ${VDB_DATA_DIR}/postgresql.conf ${VDB_DATA_DIR}/${TMPFILE}\nerrorCheck ERROR errorCopyingFile ${hostName}\n\n#\n# Declaring an associative array which will carry all the parameters\n# and there values we need to replace in configuration file.\n#\ndeclare -A PARAM_VALUE=()\nsetParameterArray ${TARGET_PORT} ${PGM_NAME}\n\nfor param in \"${!PARAM_VALUE[@]}\"; do\n        param=${param}\n        param_value=\"${PARAM_VALUE[${param}]}\"\n        log \"${param} : ${PARAM_VALUE[${param}]}\"\n        changeParameterValue \"${param}\" \"${PARAM_VALUE[${param}]}\" \"${VDB_DATA_DIR}/${TMPFILE}\"\ndone\n\n#\n# Update user provided configuration parameters in postgresql.conf file\n#\nOLD_IFS=\"$IFS\"\nIFS=$'\\n'\n\nfor values in $(echo ${CONFIG_PARAMS_STG} | tr \",\" \"\\n\" | sed -e 's/^ //g'); do\n        param=$(echo ${values} | awk '{print $1}')\n        log \"param : $param\"\n        #\n        # Check if the parameter provided is correct ...\n        #\n        paramCount=$(grep -w \"${param}\" ${VDB_DATA_DIR}/${TMPFILE} | wc -l)\n        if [[ ${paramCount} -gt 0 ]]; then\n                param_value=$(echo ${values} | awk '{print $2}')\n                log \"param value : $param_value\"\n                changeParameterValue \"${param}\" \"${param_value}\" \"${VDB_DATA_DIR}/${TMPFILE}\"\n        else\n                errorLog \"Parameter provided by the user does not exist in postgresql.conf file and is invalid : ${param}. Please provide the correct parameter and try again.\"\n                exitWithError ERROR invalidParamInConfigStg ${param}\n        fi\ndone\nIFS=\"$OLD_IFS\"\n\n#\n# Replace config file ...\n#\nmv ${VDB_DATA_DIR}/${TMPFILE} ${VDB_DATA_DIR}/postgresql.conf\nlog \"${VDB_DATA_DIR}/postgresql.conf ... updated\"\n\n#\n# Rename recovery.conf and postmaster.opts file ...\n#\nmv ${VDB_DATA_DIR}/recovery.conf ${VDB_DATA_DIR}/recovery.conf.delphix\nchmod 0700 ${VDB_DATA_DIR}/recovery.conf.delphix\nmv ${VDB_DATA_DIR}/postmaster.opts ${VDB_DATA_DIR}/postmaster.opts.delphix\n\nlog \"recovery.conf and postmaster.opts files renamed ...\"\nlog \"ls -ll ${VDB_DATA_DIR}\"\nresults=$(ls -ll ${VDB_DATA_DIR})\nlog \"$results\"\n\n##############################################################\n# Output ...\n\nprettyName=\"Postgres-$PG_VIRTUAL_PORT - ${DLPX_DATA_DIRECTORY}\"\noutputJSON='{}'\noutputJSON=$($DLPX_BIN_JQ \".dbPath = $(jqQuote \"$DLPX_DATA_DIRECTORY\")\" <<< \"$outputJSON\")\noutputJSON=$($DLPX_BIN_JQ \".prettyName = $(jqQuote \"$prettyName\")\" <<< \"$outputJSON\")\noutputJSON=$($DLPX_BIN_JQ \".errorType = $(jqQuote \"None\")\" <<< \"$outputJSON\")\noutputJSON=$($DLPX_BIN_JQ \".messageID = $(jqQuote \"None\")\" <<< \"$outputJSON\")\noutputJSON=$($DLPX_BIN_JQ \".allParams = $(jqQuote \"None\")\" <<< \"$outputJSON\")\n\nlog \"Output: $outputJSON\"\nprintf \"$outputJSON\" > \"$DLPX_OUTPUT_FILE\"\n\nlog \"======================================== ${PGM_NAME} Ended ========================================\"\nexit 0\n", 
        "library.sh": "#\n# Copyright (c) 2018, 2019 by Delphix. All rights reserved.\n#\n# library.sh\n#\n# Library of common Postgres plugin functions ...\n#\n\n###########################################################\n## Required Environment Variables ...\n\n#\n# Delphix Supplied Environment Variables ...\n#\n# DLPX_BIN_JQ=`which jq`\n# DLPX_DATA_DIRECTORY\n#\n# Plugin Specific ..\n#\nDLPX_PLUGIN_NAME=\"postgres\"\nDLPX_LOG_DIRECTORY=${DELPHIX_BIN}/../../../postgres/logs\nmkdir -p ${DLPX_LOG_DIRECTORY}\n\n###########################################################\n## Globals\n\nPlugin_VERSION=\"1.2.0\"\nERROR_LOG=${DLPX_LOG_DIRECTORY}/\"delphix_${DLPX_PLUGIN_NAME}_error.log\"\nDEBUG_LOG=${DLPX_LOG_DIRECTORY}/\"delphix_${DLPX_PLUGIN_NAME}_debug.log\"\n\n###########################################################\n## Functions ...\n\n#\n# Log infomation and die if option -d is used.\n#\nfunction log {\n        TIMESTAMP=$(date +%Y-%m-%dT%H:%M:%S)\n        Parms=$@\n        die='no'\n        if [[ ${1} = '-d' ]]; then\n                shift\n                die='yes'\n                Parms=$@\n        fi\n\n        printf \"[${TIMESTAMP}][DEBUG][%s][%s]:[$Parms]\\n\" $DLPX_PLUGIN_WORKFLOW $PGM_NAME >>$DEBUG_LOG\n        if [[ ${die} = \"yes\" ]]; then\n                exit 2\n        fi\n}\n\n#\n# Log error and write to the errorLog\n#\nfunction errorLog {\n        TIMESTAMP=$(date +%Y-%m-%dT%H:%M:%S)\n        log \"$@\"\n        echo -e \"[${DLPX_GUID}][${TIMESTAMP}][ERROR][$@]\" >>$ERROR_LOG\n}\n\n#\n# Write to log and errorLog before exiting with an error code\n#\nfunction die {\n        errorLog \"$@\"\n        exit 2\n}\n\n#\n# Function to check for errors and die with passed in error message\n#\nfunction errorCheck {\n        if [[ $? -ne 0 ]]; then\n                errorLog \"Error found, exiting ...\"\n                exitWithError ${1} ${2} ${3}\n        fi\n}\n\n#\n# Function to collect system info\n# ARCH, OSTYPE, OSVERSION\n#\nfunction getSystemInfo {\n        ARCH=$(uname -p)\n        OSTYPE=$(uname)\n        if [[ \"$OSTYPE\" = \"SunOS\" ]]; then\n                OSTYPE=\"Solaris\"\n                OSVERSION=$(uname -v)\n                OSSTR=\"$OSTYPE ${REV}(${ARCH} `uname -v`)\"\n        elif [[ \"$OSTYPE\" = \"AIX\" ]]; then\n                OSSTR=\"$OSTYPE `oslevel` (`oslevel -r`)\"\n                OSVERSION=$(oslevel)\n        elif [[ \"$OSTYPE\" = \"Linux\" ]]; then\n                if [[ -f /etc/redhat-release ]]; then\n                        OSTYPE=RedHat\n                        OSVERSION=$(cat /etc/redhat-release | sed 's/.*release\\ //' | sed 's/\\ .*//')\n                else\n                        OSTYPE=Unknown\n                        OSVERSION=Unsupported\n                fi\n        else\n                OSVERSION=Unsupported\n        fi\n}\n\n#\n# Quotes strings for use with JSON.\n#\nfunction jqQuote {\n        ${DLPX_BIN_JQ} -R '.' <<< $@\n}\n\nfunction purgeLogs {\n        MaxFileSize=20971520\n        DT=$(date '+%Y%m%d%H%M%S')\n        log \"Checking Log File Sizes ... \"\n\n        #\n        # Debug Log\n        #\n        file_size=$(du -k ${DEBUG_LOG} 2>/dev/null | tr -s '\\t' ' ' | cut -d' ' -f1)\n\n        if [[ ${file_size} -gt ${MaxFileSize} ]]; then\n                mv ${DEBUG_LOG} ${DEBUG_LOG}_${DT}\n                touch ${DEBUG_LOG}\n        fi\n\n        #\n        # Error Log\n        #\n        file_size=$(du -k ${ERROR_LOG} 2>/dev/null | tr -s '\\t' ' ' | cut -d' ' -f1)\n\n        if [[ $file_size -gt $MaxFileSize ]]; then\n                mv ${ERROR_LOG} ${ERROR_LOG}_${DT}\n                touch ${ERROR_LOG}\n        fi\n}\n\n#\n# Get Port, Data Path and Status Info ...\n#\n# Usage:\n#   RESULTS=$( pg_portStatus \"${PORT}\" )\n#   echo \"${RESULTS}\" | jq --raw-output \".status\"\n#\nfunction pg_portStatus {\n        ZPORT=${1}\n\n        #\n        # Check if Port is included in the process command ...\n        #\n        ZPSEF=$( ps -ef | grep -E \"[p]ost.*--port=${ZPORT}\" | grep -v grep )\n        #log \"Process Status: ${ZPSEF}\"\n        ZPSID=$(echo \"${ZPSEF}\" | awk -F\" \" '{print $2}')\n        ZPSCMD=$(echo \"${ZPSEF}\" | awk -F\" \" '{print $8}')\n\n        if [[ \"${ZPSID}\" == \"\" ]]; then\n                ZPSEF=$( ps -ef | grep -E \"[p]ost.*-p.*${ZPORT}\" | grep -v grep )\n                #log \"Process Status: ${ZPSEF}\"\n                PSID=$(echo \"${ZPSEF}\" | awk -F\" \" '{print $2}')\n                PSCMD=$(echo \"${ZPSEF}\" | awk -F\" \" '{print $8}')\n        fi\n\n        #log \"PSID: ${ZPSID}\"\n        #log \"PSCMD: ${ZPSCMD}\"\n        ZNEW_DATA_DIR=\"\"\n\n        #\n        # Process Exist, get data path from process ...\n        #\n        if [[ \"${ZPSID}\" != \"\" ]]; then\n                zstr=$(echo \"$ZPSEF\" | awk '{ s = \"\"; for (i = 8; i <= NF; i++) s = s $i \" \"; print s }')\n                #log \"$zstr\"\n                ZPGCMD=$(echo $zstr | awk -F\" \" '{print $1}')\n                ZPGBIN=$(dirname \"${ZPGCMD}\")\n                ZNEW_DATA_DIR=$(echo $zstr | awk '{for (I=1;I<=NF;I++) if ($I == \"-D\") {print $(I+1)};}')\n\n        else\n                #\n                # If port IS NOT included in the process command, read from postgresql.conf file ...\n                #\n                zinstances=$( ps -ef | grep -E \"[p]ost.*-D \" | grep -v grep )\n                OLD_IFS=\"$IFS\"\n                IFS=$'\\n'\n\n                for zcurrentInstance in $zinstances; do\n                        #log \"Current Instance: $zcurrentInstance\"\n                        ZPGID=$(echo $zcurrentInstance | awk -F\" \" '{print $2}')\n                        zstr=$(echo \"$zcurrentInstance\" | awk '{ s = \"\"; for (i = 8; i <= NF; i++) s = s $i \" \"; print s }')\n                        #log \"$zstr\"\n                        ZPGCMD=$(echo $zstr | awk -F\" \" '{print $1}')\n                        ZPGBIN=$(dirname \"${ZPGCMD}\")\n                        ZDATA_DIR=$(echo $zstr | awk '{for (i=1;i<=NF;i++) if ($i == \"-D\") {print $(i+1)};}')\n                        #log \"data_dir: $ZDATA_DIR\"\n                        ZTMP_PORT=$(cat ${ZDATA_DIR}/postgresql.conf | grep \"^port[[:space:]]*\" | awk -F\"=\" '{print $2}' | awk -F\" \" '{print $1}')\n                        ZTMP_PORT=$(echo $ZTMP_PORT | sed -e \"s/'//g\")\n                        #log \"data_dir/postgresql.conf port: $ZTMP_PORT\"\n\n                        if [[ \"${ZTMP_PORT}\" == \"${ZPORT}\" ]]; then\n                                ZPG_PORT=\"${ZTMP_PORT}\"\n                                ZNEW_DATA_DIR=\"${ZDATA_DIR}\"\n                                ZPSID=\"${ZPGID}\"\n                                ZPSCMD=\"${ZPGCMD}\"\n                        fi\n                done\n                IFS=\"${OLD_IFS}\"\n        fi\n\n        log \"PG_PORT: ${ZPG_PORT}\"\n        log \"PSID: ${ZPSID}\"\n        log \"PSCMD: ${ZPSCMD}\"\n        log \"Data Dir: ${ZNEW_DATA_DIR}\"\n\n        #\n        # Found valid process ...\n        #\n        ZSTATUS=\"INACTIVE\"\n        if [[ \"${ZPSID}\" != \"\" ]] && [[ \"${ZPSCMD}\" != \"\" ]] && [[ \"${ZNEW_DATA_DIR}\" != \"\" ]]; then\n                ZSTATUS=\"ACTIVE\"\n        fi\n\n        echo \"{\n        \\\"processId\\\": \\\"${ZPSID}\\\",\n        \\\"processCmd\\\": \\\"${ZPSCMD}\\\",\n        \\\"dataDir\\\": \\\"${ZNEW_DATA_DIR}\\\",\n        \\\"status\\\": \\\"${ZSTATUS}\\\"\n        }\"\n}\n\n#\n# Stop Database ...\n#\n# Usage:\n# pg_stopDatabase \"${PSID}\" \"${PSCMD}\" \"${DATA_DIR}\" \"${PG_PORT}\"\n#\nfunction pg_stopDatabase {\n        ZPSID=${1}\n        ZPSCMD=${2}\n        ZDATADIR=${3}\n        ZPG_PORT=${4}\n\n        #\n        # Found valid process ...\n        #\n        if [[ \"${ZPSID}\" != \"\" ]] && [[ \"${ZPSCMD}\" != \"\" ]] && [[ \"${ZDATADIR}\" != \"\" ]]; then\n                log \"CMD: ${ZPSCMD}\"\n                ZINSTALL=$(dirname ${ZPSCMD})\n                log \"Shutdown ...\"\n                CMD=\"${ZINSTALL}/pg_ctl -D ${ZDATADIR} stop\"\n                log \"CMD: ${CMD}\"\n                nohup ${CMD} 1>/dev/null 2>&1\n                sleep 5\n\n                ZPSEF2=$( ps -ef | grep \"${ZPSID}\" | grep -v grep )\n                ZPSID2=$(echo \"${ZPSEF2}\" | awk -F\" \" '{print $2}')\n\n                if [[ \"${ZPSID}\" == \"${ZPSID2}\" ]]; then\n                        log \"Killing ${ZPSID} ...\"\n                        kill -9 ${ZPSID}\n                        sleep 3\n                fi\n\n                #\n                # Ports can sometime take a little additional time to close, therefore,\n                # wait for 100 seconds for the port to get closed properly.\n                # In case of failure, check for PIDs occupying the port and report with proper error message.\n                #\n                OPENPORT=$(netstat -atn | grep \":${ZPG_PORT}\\W\")\n                WAIT_TIME=100\n                while [[ -n \"${OPENPORT}\" ]]; do\n                        if [[ ${WAIT_TIME} -eq 0 ]]; then\n                                OPENPORT=$(netstat -atnp | grep \":${ZPG_PORT}\\W\")\n                                PROCESS_ID=$(echo \"${OPENPORT}\" | awk '{print $7}' | awk -F \"/\" '{print $1}' | tr \"\\n\" \" \")\n                                ErrorCode=\"Port ${ZPG_PORT} failed to close on stopping the database. The port is occupied by PIDs: ${PROCESS_ID}. Please check and try again.\"\n                                log ${ErrorCode}\n                                exitWithError ERROR portNotClosed \"${ZPG_PORT}\" \"${PROCESS_ID}\"\n                        fi\n                        log \"Waiting for port ${ZPG_PORT} to finish\"\n                        sleep 1\n                        WAIT_TIME=$(( WAIT_TIME - 1 ))\n                        OPENPORT=$(netstat -atn | grep \":${ZPG_PORT}\\W\")\n                done\n        else\n                errorLog \"Error: Invalid or missing parameters ... PID: ${ZPSID}, CMD: ${ZPSCMD}, DataDir: ${ZDATADIR}\"\n        fi\n}\n\n#\n# Start Database ...\n#\n# Usage:\n# PID=$( pg_startDatabase \"${INSTALL_BIN}\" \"${DATA_DIR}\" \"${PORT}\" )\n#\nfunction pg_startDatabase {\n        ZINSTALL=\"${1}\"\n        ZDATADIR=\"${2}\"\n        ZPORT=\"${3}\"\n\n        #\n        # Validate Directories ...\n        #\n        if [[ ! -d \"${ZDATADIR}\" ]]; then\n                errorLog=\"Error: Missing Data Directory ${ZDATADIR}, exiting ...\"\n                echo \"dataDirMissing\"\n                exit 0\n        fi\n\n        if [[ ! -d \"${ZINSTALL}\" ]]; then\n                errorLog=\"Error: Missing Install Binary Directory ${ZINSTALL}, exiting ...\"\n                echo \"installDirMissing\"\n                exit 0\n        fi\n\n        #\n        # Start Database ...\n        #\n        log \"Startup ...\"\n        CMD=\"${ZINSTALL}/pg_ctl -D ${ZDATADIR} start\"\n        log \"CMD: ${CMD}\"\n        nohup ${CMD} 1>/dev/null 2>&1\n        sleep 5\n        ZPID=$(find ${ZDATADIR} -type f -name \"postmaster.pid\" 2>/dev/null | xargs head -1)\n\n        if [[ \"${ZPID}\" == \"\" ]]; then\n                echo \"Failed\"\n                exit 0\n        else\n                echo \"${ZPID}\"\n        fi\n}\n\n#\n# This function checks for all the ports which are currently in use with\n# the help of `netstat` command. If the port provided by the user is\n# currently in use then abort the program with proper message ID.\n#\nfunction isPortAvailable {\n        vPORT=$(printf \"%.0f\\n\" ${1})\n        used_ports=$(netstat -antp 2>/dev/null)\n        OLD_IFS=${IFS}\n        IFS=$'\\n'\n        for port in $used_ports; do\n                usedPorts=$(echo $port | awk -F\" \" '{print $4}' | awk -F\":\" '{print $NF}')\n\n                if [[ \"${vPORT}\" == \"${usedPorts}\" ]]; then\n                        echo \"PortNotAvailable\"\n                        exit 0\n                fi\n        done\n\n        #\n        # check if port number provided is valid. Provided port number should\n        # be in the range of 1 to 65535.\n        #\n        if [[ ${vPORT} -eq 0 ]] || [[ ${vPORT} -gt 65535 ]]; then\n                echo \"InvaidPortRange\"\n                exit 0\n        fi\nIFS=${OLD_IFS}\n}\n\n#\n# This function checks if any new tablespace is created on source.\n# If yes then it throws the error while taking new snapshot of Dsource.\n#\nfunction validatenewTableSpace {\n        LOG_DIR=${1}\n        logFile=$(ls -lrt ${LOG_DIR} 2>/dev/null | tail -1 | awk '{print $9}')\n        newTableSpaceFound=$(tail -10 ${LOG_DIR}/${logFile} 2>/dev/null | \\\n                                grep 'Create this directory for the tablespace before restarting the server')\n                if [[ -n \"${newTableSpaceFound}\" ]]; then\n                        echo \"newTableSpaceFound\"\n                        exit 0\n                fi\n}\n\n#\n# Function to return from an error other than exit 2 scenario.\n# This function takes can take n number of arguments as per the requirements.\n# From third arguments onwards, the variables will be passed to the error message.\n# The first two arguments will be :\n# Argument 1: ERROR (This parameter can be further optimized to take \"WARNING\" as input\n# so that LUA callers can handle ERROR and WARNING respectively.\n# Argument 2: Message ID\n#\nfunction exitWithError {\n        errorMessage=$($DLPX_BIN_JQ \".errorType = $(jqQuote \"$1\")\" <<< '{}')\n        errorMessage=$($DLPX_BIN_JQ \".messageID = $(jqQuote \"$2\")\" <<< \"$errorMessage\")\n        shift 2\n        if [[ $# -ne 0 ]]; then\n                var_count=0\n                allParams={}\n                for params in \"$@\"; do\n                        var_count=$(( var_count + 1))\n                        allParams=$($DLPX_BIN_JQ \".param${var_count} = $(jqQuote \"$params\")\" <<< \"$allParams\")\n                done\n                errorMessage=$($DLPX_BIN_JQ \".allParams = ${allParams}\" <<< \"$errorMessage\")\n        else\n                errorMessage=$($DLPX_BIN_JQ \".allParams = $(jqQuote \"None\")\" <<< \"$errorMessage\")\n        fi\n        echo $errorMessage > \"$DLPX_OUTPUT_FILE\"\n        log \"ERROR message JSON: ${errorMessage}\"\n        exit 0\n}\n\n\n#\n# This function creates an associative array of the parameters\n# which we need to change in the configuration file (postgresql.conf)\n# while creating dSource or vdb ...\n# In case of VDB only two arguments are required PORT and PGM_NAME\n#\nfunction setParameterArray {\n        PORT=${1}\n        PGM_NAME=${2}\n        PG_VERSION=${3}\n\n        if [[ \"${PGM_NAME}\" == \"restore.sh\" ]]; then\n                PARAM_VALUE[listen_addresses]=\"localhost\"\n                PARAM_VALUE[full_page_writes]=\"on\"\n                PARAM_VALUE[log_filename]=\"postgresql-%a.log\"\n                PARAM_VALUE[log_rotation_age]=\"1d\"\n                PARAM_VALUE[log_truncate_on_rotation]=\"on\"\n                PARAM_VALUE[checkpoint_timeout]=\"1h\"\n                PARAM_VALUE[port]=\"${PORT}\"\n                #\n                # For version below 9.6 that is 9.5 and 9.4 wal_level parameter if set to archive\n                # in postgresql.conf file does not get translated to replica because of which we have to\n                # use the wal_level parameter as minimal with hot_standby mode off ...\n                #\n                if [[ \"${PG_VERSION}\" == \"9.4\" ]] || [[ \"${PG_VERSION}\" == \"9.5\" ]]; then\n                        PARAM_VALUE[hot_standby]=\"off\"\n                        PARAM_VALUE[wal_level]=\"minimal\"\n                        PARAM_VALUE[max_wal_senders]=\"0\"\n                else\n                        PARAM_VALUE[hot_standby]=\"on\"\n                        PARAM_VALUE[wal_level]=\"hot_standby\"\n                        PARAM_VALUE[max_wal_senders]=\"2\"\n                fi\n        elif [[ \"${PGM_NAME}\" == \"provision.sh\" ]]; then\n                PARAM_VALUE[port]=\"${PORT}\"\n                PARAM_VALUE[hot_standby]=\"off\"\n        fi\n}\n\n\n#\n# This function changes the parameter value in the configuration file\n# using `sed` command. This is done in three steps :\n# 1) Comment the parameter in the configuration file.\n# 2) Check if the parameter value is quoted.\n# 3) Replace the parameter value with the provided one and uncomment the parameter.\n#\nfunction changeParameterValue {\n        param=\"${1}\"\n        param_value=\"${2}\"\n        file_path=\"${3}\"\n\n        sed -i \"/^[[:space:]]*${param}[[:space:]]*=/s/^[[:space:]]*${param}[[:space:]]*/#${param}/\" ${file_path}\n        paramValueInConf=$(grep -w \"${param}\" ${file_path} | awk -F\"=\" '{print $2}' | grep \\')\n\n        if [[ ${paramValueInConf} != \"\" ]]; then\n                sed -i \"/^[[:space:]]*#${param}[[:space:]]*=/s|=.*$|= \\'${param_value}\\' ##dlpx##|\" ${file_path}\n                sed -i \"0,/^[[:space:]]*#${param}[[:space:]]*=/s/[[:space:]]*#${param}/${param}/\" ${file_path}\n        else\n                sed -i \"0,/^[[:space:]]*${param}[[:space:]]*=/s/^[[:space:]]*#${param}[[:space:]]*=/${param} = ${param_value} ##dlpx##/\" ${file_path}\n        fi\n}\n\n###########################################################\n\npurgeLogs\n", 
        "startVirtual.sh": "#\n# Copyright (c) 2018, 2019 by Delphix. All rights reserved.\n#\n# This script is used to start the Virtual Database.\n#\n\n#\n# Program Name ...\n#\nPGM_NAME='startVirtual.sh'\n\n#\n# Load Library ...\n#\neval \"${DLPX_LIBRARY_SOURCE}\"\nlog \"======================================== ${PGM_NAME} Started ========================================\"\nhostName=$(hostname)\n\nRESULTS=$( pg_portStatus \"${PG_VIRTUAL_PORT}\" )\nlog \"Results: ${RESULTS}\"\n\nzPSID=$(echo \"${RESULTS}\" | $DLPX_BIN_JQ --raw-output \".processId\")\nzPSCMD=$(echo \"${RESULTS}\" | $DLPX_BIN_JQ --raw-output \".processCmd\")\nzDATA_DIR=$(echo \"${RESULTS}\" | $DLPX_BIN_JQ --raw-output \".dataDir\")\nzSTATUS=$(echo \"${RESULTS}\" | $DLPX_BIN_JQ --raw-output \".status\")\n\n#\n# Process Status ...\n#\nif [[ \"${zSTATUS}\" != \"ACTIVE\" ]]; then\n        NEW_DATA_DIR=\"${DLPX_DATA_DIRECTORY}/data\"\n        INSTALL_BIN=\"${PG_INSTALL_PATH}/bin\"\n\n        log \"CMD: pg_startDatabase \\\"${INSTALL_BIN}\\\" \\\"${NEW_DATA_DIR}\\\" \\\"${PG_VIRTUAL_PORT}\\\" \"\n        PID=$( pg_startDatabase \"${INSTALL_BIN}\" \"${NEW_DATA_DIR}\" \"${PG_VIRTUAL_PORT}\" )\n\n        if [[ \"${PID}\" == \"dataDirMissing\" ]]; then\n                exitWithError ERROR dataDirMissing ${NEW_DATA_DIR}\n        elif [[ \"${PID}\" == \"installDirMissing\" ]]; then\n                exitWithError ERROR installDirMissing ${INSTALL_BIN}\n        elif [[ \"${PID}\" == \"Failed\" ]]; then\n                exitWithError ERROR dbDown ${hostName}\n        fi\n\n        log \"Startup Process Id: ${PID}\"\nelse\n        log \"Warning: Database already started on port ${PG_VIRTUAL_PORT}\"\nfi\n\noutputJSON='{}'\noutputJSON=$($DLPX_BIN_JQ \".errorType = $(jqQuote \"None\")\" <<< \"$outputJSON\")\noutputJSON=$($DLPX_BIN_JQ \".messageID = $(jqQuote \"None\")\" <<< \"$outputJSON\")\noutputJSON=$($DLPX_BIN_JQ \".allParams = $(jqQuote \"None\")\" <<< \"$outputJSON\")\n\nprintf \"$outputJSON\" > \"$DLPX_OUTPUT_FILE\"\nlog \"Output : $outputJSON\"\nlog \"======================================== ${PGM_NAME} Ended ========================================\"\nexit 0\n", 
        "sourceConfigDiscovery.sh": "#\n# Copyright (c) 2018, 2019 by Delphix. All rights reserved.\n#\n# This file handles sourceConfig discovery for Postgres.\n# It will only scan for running instances of Postgres and will NOT find dormant instances\n#\n\n\n#\n# Program Name ...\n#\nPGM_NAME=\"sourceConfigDiscovery.sh\"\n\n#\n# Load Library ...\n#\neval \"${DLPX_LIBRARY_SOURCE}\"\nlog \"======================================== ${PGM_NAME} Started ========================================\"\nhostName=$(hostname -i)\n\nif [[ \"$POSTGRES_VERSION\" = '' ]] || [[ \"$POSTGRES_INSTALL_PATH\" = '' ]]; then\n        log 'POSTGRES_VERSION or POSTGRES_INSTALL_PATH not set when doing source config discovery'\n        exitWithError ERROR checkRepoParameters ${hostName}\nfi\n\n#\n# Find the postgres instances\n#\ninstances=$(ps -ef | grep -E \"[p]ost.*-D \" | grep -v grep | awk '{ s = \"\"; for (i = 8; i <= NF; i++) s = s $i \" \"; print s }')\nerrorCheck \"Error finding Postgres instances \\n${instances}\"\n\nlog \"instances: $instances\"\n\n#\n# Get configs for each instance\n#\n\nsourceConfigs='[]'\n\nsourceConfigArray=()\n\nOLD_IFS=\"${IFS}\"\nIFS=$'\\n'\n\nfor currentInstance in $instances; do\n        INSTALL_PATH=$(echo $currentInstance | awk -F \" -D \" '{print $1}')\n        INSTALL_BIN_PATH=$(dirname $INSTALL_PATH)\n        POSTGRES_SHELL_PATH=\"${INSTALL_BIN_PATH}/psql\"\n        VERSION=$($INSTALL_BIN_PATH/postgres --version 2>/dev/null | awk '{print $3}' | awk -F \".\" '{print $1\".\"$2}')\n\n        if [[ ${VERSION} = \"\" ]]; then\n                log \"Check for enterprise DB postgres\"\n                VERSION=$($INSTALL_BIN_PATH/edb-postgres --version 2>/dev/null | awk '{print $3}' | awk -F \".\" '{print $1\".\"$2}')\n        fi\n\n        if [[ \"${VERSION}\" = \"${POSTGRES_VERSION}\" ]]; then\n                log \"$currentInstance\"\n                config=$(echo \"${currentInstance}\" | awk -F\" \" '{ print $1 }')\n                RESULTS=$(echo \"${currentInstance}\" | grep -E \"[p]ost.*-p\" | grep -v grep)\n                log \"-p grep results: ${RESULTS}\"\n\n                if [[ \"${RESULTS}\" != \"\" ]]; then\n                        port=$(echo \"${currentInstance}\" | awk -F\"-p \" '{print $2}' | cut -d ' ' -f 1)\n                        dbPath=$(echo \"${currentInstance}\" | awk -F\"-D \" '{print $2}' | cut -d ' ' -f 1)\n                else\n                        RESULTS=$(echo \"${currentInstance}\" | grep -E \"[p]ost.*--port=\" | grep -v grep)\n                        log \"--port= grep results: ${RESULTS}\"\n\n                                if [[ \"${RESULTS}\" != \"\" ]]; then\n                                        port=$(echo \"${currentInstance}\" | awk -F\"--port=\" '{print $2}' | cut -d ' ' -f 1)\n                                        dbPath=$(echo \"${currentInstance}\" | awk -F\"-D \" '{print $2}' | cut -d ' ' -f 1)\n                                else\n                                        #\n                                        # If port IS NOT included in the process command, read from postgresql.conf file ...\n                                        #\n                                        dbPath=$(echo \"${currentInstance}\" | awk -F\"-D \" '{print $2}' | cut -d ' ' -f 1)\n                                        log \"dbPath: $dbPath\"\n                                        log \"cat ${dbPath}/postgresql.conf | grep -E \\\"^port = \\\"\"\n                                        port=$(cat ${dbPath}/postgresql.conf | grep -E \"^port = \" | awk -F\" = \" '{print $2}' | awk -F\" \" '{print $1}')\n\n                                        #\n                                        # Incase the database is running on default port <5432>, PORT information may not be available in config file\n                                        # Therefore, read from postmaster.pid file\n                                        #\n                                        if [[ $port = \"\" ]]; then\n                                                port=$(cat ${dbPath}/postmaster.pid | sed -n '4p')\n                                        fi\n                                        log \"postgresql.conf port: $port\"\n                                fi\n                fi\n\n        log \"config: $config\"\n        log \"port: $port\"\n        log \"dbpath: $dbPath\"\n\n        sourceConfigArray+=($dbPath)\n        prettyName=\"Postgres:${port}-$dbPath\"\n        currentSourceConfig='{}'\n        currentSourceConfig=$($DLPX_BIN_JQ \".dbPath = $(jqQuote \"$dbPath\")\" <<< \"$currentSourceConfig\")\n        currentSourceConfig=$($DLPX_BIN_JQ \".postgresPort = $port\" <<< \"$currentSourceConfig\")\n        currentSourceConfig=$($DLPX_BIN_JQ \".prettyName = $(jqQuote \"$prettyName\")\" <<< \"$currentSourceConfig\")\n        sourceConfigs=$($DLPX_BIN_JQ \". + [$currentSourceConfig]\" <<< \"$sourceConfigs\")\n\n        fi\ndone\n\n#\n# Discovering the stopped postgreSQL database clusters\n# If an environment variable `DELPHIX_PG_PATH` is present, then\n# fetch the values from it else search for the postgresql.conf\n# file.\n#\nif [[ \"${DELPHIX_PG_PATH}\" != \"\" ]]; then\n        log \"DELPHIX_PG_PATH : ${DELPHIX_PG_PATH}\"\n        for path in $(echo ${DELPHIX_PG_PATH} | tr \";\" \"\\n\"); do\n                dbPath=$(echo ${path} | awk -F\":\" '{print $2}')\n\n                var=\"\"\n                for runningInstance in \"${sourceConfigArray[@]}\"; do\n                        runningInstance=$(echo $runningInstance | sed -e 's/\\/$//g')\n                        if [[ \"$dbPath\" = \"$runningInstance\" ]]; then\n                               # The source config has already been discovered\n                               var=1 && break;\n                        fi\n                done\n\n                if [[ -z \"$var\" ]]; then\n                        port=$(cat ${dbPath}/postgresql.conf 2>/dev/null | grep -E \"^port = \" | awk -F\" = \" '{print $2}' | awk -F\" \" '{print $1}')\n                        if [[ \"$port\" != \"\" ]]; then\n                                VERSION=$(cat ${dbPath}/PG_VERSION 2>/dev/null)\n                                if [[ ${VERSION} = ${POSTGRES_VERSION} ]]; then\n                                        dsourceFile=${dbPath}/dSource\n                                        if [[ ! -f ${dsourceFile} ]]; then\n                                                prettyName=\"Postgres:${port}-$dbPath\"\n                                                currentSourceConfig='{}'\n                                                currentSourceConfig=$($DLPX_BIN_JQ \".dbPath = $(jqQuote \"$dbPath\")\" <<< \"$currentSourceConfig\")\n                                                currentSourceConfig=$($DLPX_BIN_JQ \".postgresPort = $port\" <<< \"$currentSourceConfig\")\n                                                currentSourceConfig=$($DLPX_BIN_JQ \".prettyName = $(jqQuote \"$prettyName\")\" <<< \"$currentSourceConfig\")\n                                                sourceConfigs=$($DLPX_BIN_JQ \". + [$currentSourceConfig]\" <<< \"$sourceConfigs\")\n                                        fi\n                                fi\n                        fi\n                fi\n        done\nelse\n        postgresConfigFiles=($(find / -type f -name \"postgresql.conf\" 2>/dev/null))\n\n        for configFile in \"${postgresConfigFiles[@]}\"; do\n                dbPath=$(dirname $configFile)\n                var=\"\"\n                        for runningInstance in \"${sourceConfigArray[@]}\"; do\n                        runningInstance=$(echo $runningInstance | sed -e 's/\\/$//g')\n                        if [[ \"$dbPath\" = \"$runningInstance\" ]]; then\n                                # The source config has already been discovered\n                                var=1 && break;\n                        fi\n        done\n\n        if [[ -z \"$var\" ]]; then\n                port=$(cat ${dbPath}/postgresql.conf 2>/dev/null | grep -E \"^port = \" | awk -F\" = \" '{print $2}' | awk -F\" \" '{print $1}')\n                if [[ \"$port\" != \"\" ]]; then\n                        VERSION=$(cat ${dbPath}/PG_VERSION 2>/dev/null)\n                        if [[ ${VERSION} = ${POSTGRES_VERSION} ]]; then\n                                log \"Found new Data Path : ${dbPath}\"\n                                log \"port : ${port}\"\n                                prettyName=\"Postgres:${port}-$dbPath\"\n                                log \"prettyName : $prettyName\"\n                                currentSourceConfig='{}'\n                                currentSourceConfig=$($DLPX_BIN_JQ \".dbPath = $(jqQuote \"$dbPath\")\" <<< \"$currentSourceConfig\")\n                                currentSourceConfig=$($DLPX_BIN_JQ \".postgresPort = $port\" <<< \"$currentSourceConfig\")\n                                currentSourceConfig=$($DLPX_BIN_JQ \".prettyName = $(jqQuote \"$prettyName\")\" <<< \"$currentSourceConfig\")\n                                sourceConfigs=$($DLPX_BIN_JQ \". + [$currentSourceConfig]\" <<< \"$sourceConfigs\")\n                        fi\n                fi\n        fi\ndone\nfi\nIFS=\"${OLD_IFS}\"\n\nlog \"Source Configs: $sourceConfigs\"\necho \"${sourceConfigs}\" > \"$DLPX_OUTPUT_FILE\"\n\nlog \"======================================== ${PGM_NAME} Ended ========================================\"\nexit 0\n", 
        "repoDiscovery.sh": "#\n# Copyright (c) 2018, 2019 by Delphix. All rights reserved.\n#\n# This file will handle repository discovery for Postgres ...\n#\n\n#\n# Program Name ...\n#\nPGM_NAME=\"repoDiscovery.sh\"\n\n#\n# Load Library ...\n#\neval \"${DLPX_LIBRARY_SOURCE}\"\nlog \"======================================== ${PGM_NAME} Started ========================================\"\n#\n# Get postgres postmaster services if exist ...\n#\ninstalls=$(ps -ef | grep -E \"[p]ost.*-D \" | grep -v grep)\n\n#\n# See if psql binary file exist ...\n#\nSHELLPATH=$(find /usr/bin -name psql | head -1)\nif [[ \"${SHELLPATH}\" = \"\" ]]; then\n        # Shell path not found ...\n        errorLog \"Shell (psql) not in /usr/bin path ... must use repository shell\"\nfi\n\n#\n# Build output ...\n#\nREPOSITORIES='[]'\n\nrepositoryArray=()\nversionArray=(0)\n\n# Append each install path to check for duplicates ...\nnewPath=\"\"\n\n# for each install path, get the version and add the repo object to the array\nOLD_IFS=\"$IFS\"\nIFS=$'\\n'\n\nfor install in $installs; do\n        owner=$(cut -d\" \" -f 1 <<< \"${install}\")\n        log \"Owner: |$owner|\"\n        str=$(echo \"$install\" | awk '{ s = \"\"; for (i = 8; i <= NF; i++) s = s $i \" \"; print s }')\n        log \"Process Command: |$str|\"\n        INSTALLCMD=$(awk -F\" \" '{print $1}' <<< \"${str}\")\n        INSTALLBIN=$(dirname \"${INSTALLCMD}\")\n        INSTALLSHELL=\"${INSTALLBIN}/psql\"\n        INSTALLPATH=$(dirname \"${INSTALLBIN}\")\n        log \"Install Path: ${INSTALLPATH}\"\n\n        #\n        # Skip Duplicate Paths ...\n        #\n        if [[ ! ${newPath} =~ ${INSTALLPATH} ]]; then\n                newPath=\"$newPath $INSTALLPATH\"\n\n                #\n                # Get Postgres version info ...\n                #\n                VERSION=$($INSTALLBIN/postgres --version | awk '{print $3}' | awk -F \".\" '{print $1\".\"$2}')\n                log \"Version: ${VERSION}\"\n\n                if [[ \"${VERSION}\" = \"\" ]]; then\n                        log \"Check for enterprise DB postgres\"\n                        VERSION=$($INSTALLBIN/edb-postgres --version 2>/dev/null | awk '{print $3}' | awk -F \".\" '{print $1\".\"$2}')\n                fi\n\n                if [[ \"${VERSION}\" = \"\" ]]; then\n                        errorLog \"Found Postgres install ${INSTALLPATH} but ${INSTALLSHELL} was unable to query version: ${VERSION}\"\n                        VERSION=$(echo \"${str}\" | awk -F\"/\" '{print $3}')\n\n                        if [[ \"${VERSION}\" = \"\" ]]; then\n                                  VERSION=\"(unknown)\"\n                        fi\n                fi\n\n                var=\"\"\n                for versionList in \"${versionArray[@]}\"; do\n                        if [[ ${versionList} = ${VERSION} ]]; then\n                                var=1 && break;\n                        fi\n                done\n\n                if [[ -z \"$var\" ]]; then\n                        versionArray+=($VERSION)\n                        repositoryArray+=($INSTALLPATH)\n                        PRETTYNAME=\"Postgres vFiles (${VERSION})\"\n                        CURRENT_REPO='{}'\n                        CURRENT_REPO=$($DLPX_BIN_JQ \".postgresInstallPath = $(jqQuote \"$INSTALLPATH\")\" <<< \"$CURRENT_REPO\")\n                        CURRENT_REPO=$($DLPX_BIN_JQ \".postgresShellPath = $(jqQuote \"$INSTALLSHELL\")\" <<< \"$CURRENT_REPO\")\n                        CURRENT_REPO=$($DLPX_BIN_JQ \".version = $(jqQuote \"$VERSION\")\" <<< \"$CURRENT_REPO\")\n                        CURRENT_REPO=$($DLPX_BIN_JQ \".repositoryName = $(jqQuote \"$PRETTYNAME\")\" <<< \"$CURRENT_REPO\")\n                        REPOSITORIES=$($DLPX_BIN_JQ \". + [$CURRENT_REPO]\" <<< \"$REPOSITORIES\")\n                fi\n\n        fi\ndone\n\n#\n# Discovering the instances for stopped databases\n# If an environment variable `DELPHIX_PG_PATH` is present, then\n# fetch the values from it else search for the binaries in particular\n# directories. for e.g /var or /opt.\n#\n\nif [[ \"${DELPHIX_PG_PATH}\" != \"\" ]]; then\n        log \"DELPHIX_PG_PATH : ${DELPHIX_PG_PATH}\"\n        for path in $(echo ${DELPHIX_PG_PATH} | tr \";\" \"\\n\"); do\n                INSTALLBIN=$(echo ${path} | awk -F\":\" '{print $1}')\n                INSTALLPATH=$(dirname $INSTALLBIN)\n\n                var=\"\"\n                for repository in ${repositoryArray[@]}; do\n                        if [[ $INSTALLPATH = $repository ]]; then\n                                # The repository has already been discovered\n                                var=1 && break;\n                        fi\n                done\n\n        if  [[ -z \"$var\" ]]; then\n                INSTALLSHELL=$INSTALLBIN/psql\n                VERSION=$($INSTALLBIN/postgres --version 2>/dev/null | awk '{print $3}' | awk -F \".\" '{print $1\".\"$2}')\n\n                if [[ \"${VERSION}\" = \"\" ]]; then\n                        # Check for enterprise DB postgres\n                        VERSION=$($INSTALLBIN/edb-postgres --version 2>/dev/null | awk '{print $3}' | awk -F \".\" '{print $1\".\"$2}')\n                fi\n\n                vars=\"\"\n                for versionList in \"${versionArray[@]}\"; do\n                        if [[ ${versionList} = ${VERSION} ]]; then\n                                vars=1 && break;\n                        fi\n                done\n\n                if [[ -z \"$vars\" ]]; then\n                        if [[ $VERSION != \"\" ]]; then\n                                versionArray+=($VERSION)\n                                # Found Postgres database in stopped state\n                                REPOSITORYNAME=\"Postgres vFiles (${VERSION})\"\n                                CURRENT_REPO='{}'\n                                CURRENT_REPO=$($DLPX_BIN_JQ \".postgresInstallPath = $(jqQuote \"$INSTALLPATH\")\" <<< \"$CURRENT_REPO\")\n                                CURRENT_REPO=$($DLPX_BIN_JQ \".postgresShellPath = $(jqQuote \"$INSTALLSHELL\")\" <<< \"$CURRENT_REPO\")\n                                CURRENT_REPO=$($DLPX_BIN_JQ \".version = $(jqQuote \"$VERSION\")\" <<< \"$CURRENT_REPO\")\n                                CURRENT_REPO=$($DLPX_BIN_JQ \".repositoryName = $(jqQuote \"$REPOSITORYNAME\")\" <<< \"$CURRENT_REPO\")\n                                REPOSITORIES=$($DLPX_BIN_JQ \". + [$CURRENT_REPO]\" <<< \"$REPOSITORIES\")\n                        fi\n                fi\n        fi\n        done\nelse\n        installs=($(find /var -type f -name \"pg_ctl\" 2>/dev/null))\n        installs+=($(find /opt -type f -name \"pg_ctl\" 2>/dev/null))\n\n        for install in \"${installs[@]}\"; do\n                INSTALLBIN=$(dirname $install)\n                INSTALLPATH=$(dirname $INSTALLBIN)\n                var=\"\"\n                for repository in ${repositoryArray[@]}; do\n                        if [[ $INSTALLPATH = $repository ]]; then\n                                # The repository has already been discovered\n                                var=1 && break;\n                        fi\n                done\n\n        if  [[ -z \"$var\" ]]; then\n                INSTALLSHELL=$INSTALLBIN/psql\n                VERSION=$($INSTALLBIN/postgres --version 2>/dev/null | awk '{print $3}' | awk -F \".\" '{print $1\".\"$2}')\n\n                if [[ \"${VERSION}\" = \"\" ]]; then\n                        log \"Check for enterprise DB postgres\"\n                        VERSION=$($INSTALLBIN/edb-postgres --version 2>/dev/null | awk '{print $3}' | awk -F \".\" '{print $1\".\"$2}')\n                fi\n\n                vars=\"\"\n                for versionList in \"${versionArray[@]}\"; do\n                        if [[ ${versionList} = ${VERSION} ]]; then\n                                vars=1 && break;\n                        fi\n                done\n\n                if [[ -z \"$vars\" ]]; then\n                        if [[ $VERSION != \"\" ]]; then\n                                versionArray+=($VERSION)\n                                log \"Found Postgres database in stopped state\"\n                                log \"Install Path: ${INSTALLPATH}\"\n                                REPOSITORYNAME=\"Postgres vFiles (${VERSION})\"\n                                CURRENT_REPO='{}'\n                                CURRENT_REPO=$($DLPX_BIN_JQ \".postgresInstallPath = $(jqQuote \"$INSTALLPATH\")\" <<< \"$CURRENT_REPO\")\n                                CURRENT_REPO=$($DLPX_BIN_JQ \".postgresShellPath = $(jqQuote \"$INSTALLSHELL\")\" <<< \"$CURRENT_REPO\")\n                                CURRENT_REPO=$($DLPX_BIN_JQ \".version = $(jqQuote \"$VERSION\")\" <<< \"$CURRENT_REPO\")\n                                CURRENT_REPO=$($DLPX_BIN_JQ \".repositoryName = $(jqQuote \"$REPOSITORYNAME\")\" <<< \"$CURRENT_REPO\")\n                                REPOSITORIES=$($DLPX_BIN_JQ \". + [$CURRENT_REPO]\" <<< \"$REPOSITORIES\")\n                        fi\n                fi\n        fi\n\ndone\nfi\nIFS=\"$OLD_IFS\"\nlog \"Output: ${REPOSITORIES}\"\necho \"$REPOSITORIES\" > \"$DLPX_OUTPUT_FILE\"\n\nlog \"======================================== ${PGM_NAME} Ended ========================================\"\nexit 0\n", 
        "recordVirtual.sh": "#\n# Copyright (c) 2018 by Delphix. All rights reserved.\n#\n\n#\n# Program Name ...\n#\nPGM_NAME='recordVirtual.sh'\n\n#\n# Load Library ...\n#\neval \"${DLPX_LIBRARY_SOURCE}\"\nlog \"======================================== ${PGM_NAME} Started ========================================\"\n\nID=$$\nDT=$(date '+%Y%m%d%H%M%S')\nPG_VIRTUAL_IP=$(hostname -i)\n\noutputJson='{}'\noutputJson=$($DLPX_BIN_JQ \".snapshotId = \\\"$ID\\\" \" <<< \"$outputJson\")\noutputJson=$($DLPX_BIN_JQ \".timeStamp = \\\"$DT\\\" \" <<< \"$outputJson\")\noutputJson=$($DLPX_BIN_JQ \".snapHost = \\\"$PG_VIRTUAL_IP\\\" \" <<< \"$outputJson\")\noutputJson=$($DLPX_BIN_JQ \".snapPort = \\\"$PG_VIRTUAL_PORT\\\" \" <<< \"$outputJson\")\noutputJson=$($DLPX_BIN_JQ \".snapPath = \\\"$DLPX_DATA_DIRECTORY\\\" \" <<< \"$outputJson\")\noutputJson=$($DLPX_BIN_JQ \".version = \\\"$PG_VERSION\\\" \" <<< \"$outputJson\")\necho \"$outputJson\" > \"$DLPX_OUTPUT_FILE\"\nlog \"Output: $outputJson\"\n\nlog \"======================================== ${PGM_NAME} Ended ========================================\"\nexit 0\n", 
        "stopStaging.sh": "#\n# Copyright (c) 2018, 2019 by Delphix. All rights reserved.\n#\n# This script is used to stop the database\n#\n\n#\n# Program Name ...\n#\nPGM_NAME='stopStaging.sh'\n\n#\n# Load Library ...\n#\neval \"${DLPX_LIBRARY_SOURCE}\"\nlog \"======================================== ${PGM_NAME} Started ========================================\"\n\nRESULTS=$( pg_portStatus \"${PG_STAGED_PORT}\" )\nlog \"Results: ${RESULTS}\"\n\nzPSID=$(echo \"${RESULTS}\" | $DLPX_BIN_JQ --raw-output \".processId\")\nzPSCMD=$(echo \"${RESULTS}\" | $DLPX_BIN_JQ --raw-output \".processCmd\")\nzDATA_DIR=$(echo \"${RESULTS}\" | $DLPX_BIN_JQ --raw-output \".dataDir\")\nzSTATUS=$(echo \"${RESULTS}\" | $DLPX_BIN_JQ --raw-output \".status\")\n\n#\n# Process Status ...\n#\nif [[ \"${zSTATUS}\" == \"ACTIVE\" ]] && [[ \"${zDATA_DIR}\" == \"${DLPX_DATA_DIRECTORY}/data\" ]]; then\n        log \"CMD: ${zPSCMD}\"\n        pg_stopDatabase \"${zPSID}\" \"${zPSCMD}\" \"${zDATA_DIR}\" \"${PG_STAGED_PORT}\"\nelse\n        log \"No process found for data directory ${DLPX_DATA_DIRECTORY}/data with port ${PG_STAGED_PORT}\"\nfi\n\noutputJSON='{}'\noutputJSON=$($DLPX_BIN_JQ \".errorType = $(jqQuote \"None\")\" <<< \"$outputJSON\")\noutputJSON=$($DLPX_BIN_JQ \".messageID = $(jqQuote \"None\")\" <<< \"$outputJSON\")\noutputJSON=$($DLPX_BIN_JQ \".allParams= $(jqQuote \"None\")\" <<< \"$outputJSON\")\nlog \"Output: $outputJSON\"\nprintf \"$outputJSON\" > \"$DLPX_OUTPUT_FILE\"\n\nlog \"======================================== ${PGM_NAME} Ended ========================================\"\nexit 0\n", 
        "lib.lua": "--\n-- Copyright (c) 2018, 2019 by Delphix. All rights reserved.\n--\n\n-- Function getPropValString will consume input parameters provided as property value pair for setting up database configurations in order to link and provision datasets.\n-- This function will return propValString in following format.\n-- \"param1 value1 param2 value2\"\n\nfunction getPropValString(config_settings)\n        propValString=\"\"\n        if config_settings ~= nil then\n                i=0\n                for k, v in pairs(config_settings) do\n                        if v.propertyName ~= \"\" and v.value ~= \"\" then\n                                if i >0 then propValString = propValString .. \" \" end\n                                propValString = propValString .. v.propertyName .. \" \" .. v.value .. \",\"\n                                i = i + 1\n                        else\n                                propValString = propValString .. \",\"\n                                i = i + 1\n                        end\n                end\n                return propValString\n        end\nend\n", 
        "validate.sh": "#\n# Copyright (c) 2018, 2019 by Delphix. All rights reserved.\n#\n# This script check for newly created tablespaces on source ...\n#\n\nPGM_NAME=\"validate.sh\"\neval \"${DLPX_LIBRARY_SOURCE}\"\nlog \"======================================== ${PGM_NAME} Started ========================================\"\n\nNEW_DATA_DIR=${DLPX_DATA_DIRECTORY}/data\nlog \"NEW_DATA_DIR : $NEW_DATA_DIR\"\n\nif [[ ! -f ${NEW_DATA_DIR}/postmaster.pid ]]; then\n        if [[ -d ${NEW_DATA_DIR}/pg_log ]]; then\n                databaseStatus=$(validatenewTableSpace ${NEW_DATA_DIR}/pg_log)\n                if [[ \"${databaseStatus}\" = \"newTableSpaceFound\" ]]; then\n                        exitWithError ERROR newTableSpaceFound\n                fi\n        else\n                #\n                # Check for EDB ...\n                #\n                databaseStatus=$(validatenewTableSpace ${NEW_DATA_DIR}/log)\n                if [[ ${databaseStatus} = \"newTableSpaceFound\" ]]; then\n                        exitWithError ERROR newTableSpaceFound\n                fi\n        fi\n\n        if [[ -f ${NEW_DATA_DIR}/scripts/WalBreakChainDetected ]]; then\n                ErrorCode=$(cat ${NEW_DATA_DIR}/scripts/WalBreakChainDetected)\n                log \"${ErrorCode}\"\n                exitWithError ERROR walLogChainBreakDetected \"${ErrorCode}\"\n        elif [[ -f ${NEW_DATA_DIR}/scripts/InvalidRecordFileFound ]]; then\n                ErrorCode=$(cat ${NEW_DATA_DIR}/scripts/InvalidRecordFileFound)\n                log \"${ErrorCode}\"\n                exitWithError ERROR walLogChainBreakDetected \"${ErrorCode}\"\n        fi\n\nfi\n\noutputJSON='{}'\noutputJSON=$($DLPX_BIN_JQ \".errorType = $(jqQuote \"None\")\" <<< \"$outputJSON\")\noutputJSON=$($DLPX_BIN_JQ \".messageID = $(jqQuote \"None\")\" <<< \"$outputJSON\")\noutputJSON=$($DLPX_BIN_JQ \".allParams = $(jqQuote \"None\")\" <<< \"$outputJSON\")\nprintf \"$outputJSON\" > \"$DLPX_OUTPUT_FILE\"\nlog \"Output : $outputJSON\"\n\nlog \"======================================== ${PGM_NAME} Ended ========================================\"\n", 
        "status.sh": "#\n# Copyright (c) 2018 by Delphix. All rights reserved.\n#\n# Program Name ...\n#\nPGM_NAME='status.sh'\n#\n# Load Library ...\n#\n\neval \"${DLPX_LIBRARY_SOURCE}\"\nlog \"======================================== ${PGM_NAME} Started ========================================\"\n\nif [[ \"$POSTGRESQL_STATUS_TYPE\" = 'staged' ]]; then\n        log \"Status for staging database\"\n        PORT=${PG_STAGED_PORT}\nfi\n\nif [[ \"$POSTGRESQL_STATUS_TYPE\" = 'virtual' ]]; then\n        log \"Status for virutal database\"\n        PORT=${PG_VIRTUAL_PORT}\nfi\n\nlog \"Target Port: ${PORT}\"\nRESULTS=$( pg_portStatus \"${PORT}\" )\nlog \"Results: ${RESULTS}\"\nzPORT=$(echo \"${RESULTS}\" | $DLPX_BIN_JQ --raw-output \".port\")\nzPSID=$(echo \"${RESULTS}\" | $DLPX_BIN_JQ --raw-output \".processId\")\nzPSCMD=$(echo \"${RESULTS}\" | $DLPX_BIN_JQ --raw-output \".processCmd\")\nzDATA_DIR=$(echo \"${RESULTS}\" | $DLPX_BIN_JQ --raw-output \".dataDir\")\nzSTATUS=$(echo \"${RESULTS}\" | $DLPX_BIN_JQ --raw-output \".status\")\n\nlog \"Status Results ... \"\nlog \"--------------------------\"\nlog \"Port: ${zPORT}\"\nlog \"PSID: ${zPSID}\"\nlog \"PSCMD: ${zPSCMD}\"\nlog \"Data Dir: ${zDATA_DIR}\"\nlog \"Status: ${zSTATUS}\"\n#\n# Found valid process ...\n#\nif [[ \"${zSTATUS}\" = \"ACTIVE\" ]] && [[ \"${zDATA_DIR}\" == \"${DLPX_DATA_DIRECTORY}/data\" ]]; then\n        printf \"\\\"ACTIVE\\\"\" > \"$DLPX_OUTPUT_FILE\"\nelse\n        printf \"\\\"INACTIVE\\\"\" > \"$DLPX_OUTPUT_FILE\"\nfi\n\nlog \"======================================== ${PGM_NAME} Ended ========================================\"\nexit 0\n", 
        "reconfigure.sh": "#\n# Copyright (c) 2018, 2019 by Delphix. All rights reserved.\n#\n\n#\n# Program Name ...\n#\nPGM_NAME=\"reconfigure.sh\"\n\n#\n# Load Library ...\n#\neval \"${DLPX_LIBRARY_SOURCE}\"\nlog \"======================================== ${PGM_NAME} Started ========================================\"\nhostName=$(hostname)\n\nif [[ ! -d ${DLPX_DATA_DIRECTORY} ]]; then\n        errorLog \"Delphix mount Directory Missing : ${DLPX_DATA_DIRECTORY}, exiting ...\"\n        exitWithError ERROR dirMissing \"${DLPX_DATA_DIRECTORY}\"\nfi\n\n#\n# Output ...\n#\nprettyName=\"Postgres-$PG_VIRTUAL_PORT - ${DLPX_DATA_DIRECTORY}\"\noutputJSON='{}'\noutputJSON=$($DLPX_BIN_JQ \".dbPath = $(jqQuote \"$DLPX_DATA_DIRECTORY\")\" <<< \"$outputJSON\")\noutputJSON=$($DLPX_BIN_JQ \".prettyName = $(jqQuote \"$prettyName\")\" <<< \"$outputJSON\")\noutputJSON=$($DLPX_BIN_JQ \".errorType = $(jqQuote \"None\")\" <<< \"$outputJSON\")\noutputJSON=$($DLPX_BIN_JQ \".messageID = $(jqQuote \"None\")\" <<< \"$outputJSON\")\noutputJSON=$($DLPX_BIN_JQ \".allParams = $(jqQuote \"None\")\" <<< \"$outputJSON\")\n\nlog \"Output: $outputJSON\"\nprintf \"$outputJSON\" > \"$DLPX_OUTPUT_FILE\"\n\nlog \"======================================== ${PGM_NAME} Ended ========================================\"\nexit 0\n", 
        "restore.sh": "#\n# Copyright (c) 2018, 2019 by Delphix. All rights reserved.\n#\n# This script handles the creation of Dsource on staging/target server.\n# Using pg_basebackup utility we are taking the physical backup of the\n# database on the mounted path and after making the required changes in configuration\n# file (postgresql.conf) we are starting the database.\n\n#\n# Program Name ...\n#\nPGM_NAME='restore.sh'\n\n#\n# Load Library ...\n#\neval \"${DLPX_LIBRARY_SOURCE}\"\nlog \"======================================== ${PGM_NAME} Started ========================================\"\n\nhostName=$(hostname)\nPG_STAGED_BIN=\"${PG_INSTALL_PATH}/bin\"\nPG_STAGED_DATA=\"${DLPX_DATA_DIRECTORY}/data\"\nDT=$(date '+%Y%m%d%H%M%S')\n##############################################################\n#\n# functions ...\n#\n\n#\n# This function validate the zip file and then unzip the\n# backup file in data directory ...\n#\nfunction unzipBackupFile {\n        BACKUP_ZIPPED_FILE=${1}\n        PG_STAGED_DATA=${2}\n        #\n        # Validate the zip file ...\n        #\n        validateZipFile=$(zipinfo ${BACKUP_ZIPPED_FILE} | grep \"base.tar\" | wc -l)\n        if [[ ${validateZipFile} -eq 0 ]] || [[ ${validateZipFile} -gt 1 ]]; then\n                errorLog \"Provided zip file is invalid. File : ${BACKUP_ZIPPED_FILE}\"\n                exitWithError ERROR invalidZipFile ${BACKUP_ZIPPED_FILE}\n        fi\n\n        #\n        # Unzip the Backup File in Data Directory ...\n        #\n        unzip ${BACKUP_ZIPPED_FILE} -d ${PG_STAGED_DATA}\n}\n\n#\n# This function extract the base.tar file and tablespaces tar file in\n# data directory. It also Create the symbolic link for each tablespace\n# oid in pg_tblspc directory.\n#\nfunction extractTarFiles {\n        #\n        # Extract the base.tar file\n        #\n        log \"extracting base.tar file...\"\n        PG_STAGED_DATA=$1\n        if [[ ! -s ${PG_STAGED_DATA}/base.tar ]]; then\n                errorLog \"Backup tar file is not valid. File : ${PG_STAGED_DATA}/base.tar\"\n                exitWithError ERROR invalidBackupFile ${PG_STAGED_DATA}/base.tar\n        fi\n\n        tar -xf ${PG_STAGED_DATA}/base.tar -C ${PG_STAGED_DATA}\n        tableSpacesArray=($(ls -lrt ${PG_STAGED_DATA}/[0-9]*.tar | awk '{print $9}' | awk -F \"/\" '{print $NF}' | awk -F \".\" '{print $1}'))\n\n        if [[ -f ${PG_BACKUP_PATH}/pg_wal.tar ]]; then\n                tar -xf ${PG_STAGED_DATA}/pg_wal.tar -C ${PG_STAGED_DATA}/pg_wal\n        fi\n\n        #\n        # Check for tablespaces present on source database. If true:\n        # Step 1: Create a directory \"tablespace\" inside data directory.\n        # Step 2: Create the directory <tablespace_oid> inside above.\n        # Step 3: Extract the \"<tablespace>.tar\" file in above directory.\n        # Step 3: Create the symbolic link for each tablespace oid in pg_tblspc.\n        #\n        if [[ ${#tableSpacesArray[@]} -gt 0 ]]; then\n                log \"Tablespace : ${tableSpacesArray[@]}\"\n                PG_TABLE_SPACE=\"${PG_STAGED_DATA}/tablespace\"\n                mkdir -p ${PG_TABLE_SPACE}\n                rm ${PG_STAGED_DATA}/pg_tblspc/*\n                #\n                # Removing the tablespace_map file if exists.\n                # This file has been introduced in postgreSQL version 9.5 to maintain\n                # the tablespace symbolic links which are restored during recovery ...\n                #\n                if [[ -f ${PG_STAGED_DATA}/tablespace_map ]]; then\n                        rm -f ${PG_STAGED_DATA}/tablespace_map\n                fi\n\n                for tableSpace in \"${tableSpacesArray[@]}\"; do\n                        if [[ ! -s ${PG_STAGED_DATA}/${tableSpace}.tar ]]; then\n                                errorLog \"Backup tar file is not valid. File : ${PG_STAGED_DATA}/${tableSpace}.tar\"\n                                exitWithError ERROR invalidBackupFile ${PG_STAGED_DATA}/${tableSpace}.tar\n                        fi\n\n                        mkdir -p ${PG_TABLE_SPACE}/${tableSpace}\n                        log \"extracting ${tableSpace}.tar file ...\"\n                        tar -xf ${PG_STAGED_DATA}/${tableSpace}.tar -C ${PG_TABLE_SPACE}/${tableSpace}\n                        ln -s ../tablespace/\"${tableSpace}\" \"${PG_STAGED_DATA}\"/\"pg_tblspc\"\n                        log \"created link : ln -s ../tablespace/${tableSpace} ${PG_STAGED_DATA}/pg_tblspc \"\n                done\n        fi\n        #\n        # Remove the tar files ...\n        #\n        rm -f ${PG_STAGED_DATA}/*.tar\n}\n\n##############################################################\n# Validation Checks...\n\n#\n# Validate if all of external_backup and delphix_initiated parameters are provided ...\n# If yes then we should exit as we can perform linking through only one way\n# either through external_backup or by delphix_initiated process ...\n#\nif [[ \"${WAL_LOG_PATH}\" != \"\" ]] && [[ \"${IN_SYNC_FLAG}\" == \"true\" ]] && [[ \"${BACKUP_FLAG}\" == \"true\" ]]; then\n        errorLog \"We can perform linking through only one way either through external_backup or by delphix_initiated process. Please provide parameters of only one of the process.\"\n        exitWithError ERROR allProcessParamsAreSupplied\nfi\n\n#\n# Validate if `IN_SYNC_FLAG` is true. If it is true then check if the\n# delphix_initiated parameters are provided ...\n#\nif [[ \"${IN_SYNC_FLAG}\" == \"true\" ]]; then\n        if [[ \"${PG_REPL_USER}\" = \"\" ]] && [[ \"${PG_REPL_PASS}\" = \"\" ]] && [[ \"${PG_SOURCE_IP}\" = \"\" ]] && [[ \"${PG_SOURCE_PORT}\" = \"\" ]]; then\n                errorLog \"keepStagingInSync flag is true but it's dependent delphix_initiated parameters are not provided, exiting ...\"\n                exitWithError ERROR parametersNotProvided\n        fi\nfi\n\n#\n# Validate the `PG_BACKUP_PATH` if external backup process is used to create dSource ...\n#\nif [[ \"${PG_BACKUP_PATH}\" != \"\" ]]; then\n        if [[ ! -d \"${PG_BACKUP_PATH}\" ]]; then\n                errorLog \"Provided backup path does not exist, exiting ...\"\n                exitWithError ERROR directoryNotFound \"${PG_BACKUP_PATH}\"\n        fi\nfi\n\n#\n# Validate the `WAL_LOG_PATH` if external backup process is used to create dSource and\n# wal log segments are used to keep dSource in sync with source ...\n#\nif [[ \"${BACKUP_FLAG}\" == \"false\" ]] && [[ \"${IN_SYNC_FLAG}\" == \"false\" ]] && [[ \"${WAL_LOG_PATH}\" != \"\" ]]; then\n        if [[ ! -d \"${WAL_LOG_PATH}\" ]]; then\n                errorLog \"Provided wal log path does not exist, exiting ...\"\n                exitWithError ERROR directoryNotFound \"${WAL_LOG_PATH}\"\n        fi\nfi\n\n#\n# Validate database connectivity in case of delphix initiated backups ...\n#\nif [[ \"${BACKUP_FLAG}\" = \"true\" ]]; then\n        validateConnection=$(${PG_STAGED_BIN}/pg_isready -h ${PG_SOURCE_IP} -p ${PG_SOURCE_PORT})\n        if [[ \"${validateConnection}\" =~ \"no response\" ]]; then\n                log \"Unable to connect to database server. Connection refused.\"\n                exitWithError ERROR connectivityIssue\n        fi\nfi\n\n#############################################################\n#\n# Check whether the input port is valid.\n# This check should not happen in case of resynchronization of dsource\n#\nisRsync=$(find ${DLPX_DATA_DIRECTORY} -type f -name \"postgresql.conf\" 2>/dev/null | wc -l)\n\nif [[ ${isRsync} -eq 0 ]]; then\n        portStatus=$(isPortAvailable \"${PG_STAGED_PORT}\")\n\n        if [[ \"${portStatus}\" == \"PortNotAvailable\" ]]; then\n                errorLog \"Provided port : ${PG_STAGED_PORT} is already in use. Please provide a different port.\"\n                exitWithError ERROR portInUse \"${PG_STAGED_PORT}\"\n        elif [[ \"${portStatus}\" == \"InvaidPortRange\" ]]; then\n                errorLog \"Input port : ${PG_STAGED_PORT} is invalid. Please provide a valid port number.\"\n                exitWithError ERROR invalidPortRange ${PG_STAGED_PORT}\n        fi\nfi\n\n##################################################################\n#\n# Validate if parameters are provided to keep dSource in sync ...\n#\nif [[ \"${WAL_LOG_PATH}\" == \"\" ]] && [[ \"${IN_SYNC_FLAG}\" == \"false\" ]] && [[ \"${BACKUP_FLAG}\" == \"false\" ]]; then\n        errorLog \"Please provide either wal log path or allow the dSource to be in sync through streaming replication\"\n        exitWithError ERROR dSourceNotInSync\nfi\n\n#############################################################\n#\n# Validate delphix mount directory ...\n#\nlog \"Delphix Mount: ${DLPX_DATA_DIRECTORY}\"\n\nif [[ ! -d \"${DLPX_DATA_DIRECTORY}\" ]]; then\n        errorLog \"Delphix mount Directory Missing : ${DLPX_DATA_DIRECTORY}, exiting ...\"\n        exitWithError ERROR dirMissing ${DLPX_DATA_DIRECTORY}\nfi\n\n#############################################################\n#\n# If we are taking consecutive full backup with pg_basebackup, the data directory\n# may already exist because of first run. This is an error and hence we need\n# to perform cleanup of data directory before initiating a new backup.\n# Before removing data directory stop the database if it is active.\n#\nif [[ ${isRsync} -ne 0 ]]; then\n        PSID=$(find ${PG_STAGED_DATA} -type f -name \"postmaster.pid\" 2>/dev/null | xargs head -1)\n        #\n        # Stopping database ...\n        #\n        if [[ ${PSID} != \"\"  ]]; then\n                log \"pg_stopDatabase ${PSID} ${PG_STAGED_BIN}/psql ${PG_STAGED_DATA} ${PG_STAGED_PORT}\"\n                pg_stopDatabase \"${PSID}\" \"${PG_STAGED_BIN}/psql\" ${PG_STAGED_DATA} ${PG_STAGED_PORT}\n        fi\n        rm -rf ${PG_STAGED_DATA} 2>/dev/null\nfi\n\n##############################################################\n#\n# Make the data directory under the mount point to allow possibly\n# startup logs and other files to be written locally.\n#\nmkdir -p ${PG_STAGED_DATA}\n\nif [[ ! -d \"${PG_STAGED_DATA}\" ]]; then\n        errorLog \"Data Directory Missing : ${PG_STAGED_DATA}, exiting ...\"\n        exitWithError ERROR dataDirMissing ${PG_STAGED_DATA}\nfi\n\n#########################################################################\n#\n# Check for the `unzip` utility if it is installed in the host ...\n# We will check this binary only when `external backup` routine is executed ...\n#\nif [[ \"${BACKUP_FLAG}\" == \"false\" ]]; then\n        UNZIP_BIN=$(which unzip)\n        if [[ ! -f ${UNZIP_BIN} ]]; then\n                errorLog \"unzip utility not found\"\n                exitWithError ERROR unzipUtilityNotFound ${hostName}\n        fi\nfi\n\n#\n# Check for the backup files `PostgreSQL_TYYYYMMDD.zip` present under PG_BACKUP_PATH directory ...\n#\nif [[ \"${BACKUP_FLAG}\" == \"false\" ]]; then\n        BACKUP_FILE=$(ls -lrt ${PG_BACKUP_PATH}/PostgreSQL_T[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9].zip 2>/dev/null | awk '{print $9}')\n        if [[ \"${BACKUP_FILE}\" == \"\" ]]; then\n                errorLog \"Backup File with format : PostgreSQL_TYYYYMMDD.zip was not found\"\n                exitWithError ERROR backupFileNotFound ${hostName}\n        else\n                LATEST_FILE_DATE=$(echo \"${BACKUP_FILE}\" | awk -F \"/\" '{print $NF}' | awk -F \"_\" '{print $2}' | awk -F \".\" '{print $1}' | sort -rn | head -1)\n                LATEST_FILE=$(ls -lrt ${PG_BACKUP_PATH}/*${LATEST_FILE_DATE}* | awk '{print $9}'| tail -1)\n                log \"Backup File Used To Create dSource : ${LATEST_FILE}\"\n        fi\n\n        #\n        # Call unzipBackupFile function to unzip the backup file ...\n        #\n        unzipBackupFile ${LATEST_FILE} ${PG_STAGED_DATA}\n\n        #\n        # Call extractTarFiles function to extract the tar files ...\n        #\n        log \"extractTarFiles ${PG_STAGED_DATA}\"\n        extractTarFiles ${PG_STAGED_DATA}\nfi\n\n##############################################################\n## Create Standby Base Data Backup ...\n\nif [[ \"${BACKUP_FLAG}\" == \"true\" ]]; then\n        log \"Running Backup ...\"\n        #\n        # Run Backup ...\n        #\n        psqlErrorLog=psqlErrorLog_${DT}\n        log \"${PG_STAGED_BIN}/pg_basebackup -D ${PG_STAGED_DATA} -F t -v -w -P -h ${PG_SOURCE_IP} -p ${PG_SOURCE_PORT} -U ${PG_REPL_USER}\"\n        PGPASSWORD_OLD=${PGPASSWORD}\n        export PGPASSWORD=${PG_REPL_PASS}\n        ${PG_STAGED_BIN}/pg_basebackup -D ${PG_STAGED_DATA} -F t -v -w -P -h ${PG_SOURCE_IP} -p ${PG_SOURCE_PORT} -U ${PG_REPL_USER} 2>/${DLPX_LOG_DIRECTORY}/${psqlErrorLog}\n\n        if [[ $? -ne 0 ]]; then\n                #\n                # Check whether the input parameter (replication user) is correct...\n                #\n                errorlog=$(cat ${DLPX_LOG_DIRECTORY}/${psqlErrorLog} | tr '\\n' \" \")\n                errorLog \"${errorlog}\"\n                exitWithError ERROR pgBasebackupFail \"${errorlog}\"\n        fi\n        rm -f ${DLPX_LOG_DIRECTORY}/${psqlErrorLog}\n\n        #\n        # Call extractTarFiles function to extract the tar files ...\n        #\n        log \"extractTarFiles ${PG_STAGED_DATA}\"\n        extractTarFiles ${PG_STAGED_DATA}\n\nfi\nexport PGPASSWORD=${PGPASSWORD_OLD}\n\n##############################################################\n## Configure the standby slave ...\n\n#\n# Modify the staging postgresql.conf file ...\n# Make backup copy of source config file ...\n#\ncp ${PG_STAGED_DATA}/postgresql.conf ${PG_STAGED_DATA}/postgresql.conf_${DT}\nerrorCheck ERROR errorCopyingFile ${hostName}\n\n#\n# Temporary Config File ...\n#\nTMPFILE=\"tmp.conf_${DT}\"\ncp ${PG_STAGED_DATA}/postgresql.conf ${PG_STAGED_DATA}/${TMPFILE}\nerrorCheck ERROR errorCopyingFile ${hostName}\n\n\n#\n# Declaring an associative array which will carry all the parameters\n# and there values we need to replace in configuration file.\n#\ndeclare -A PARAM_VALUE=()\nsetParameterArray ${PG_STAGED_PORT} ${PGM_NAME} ${PG_VERSION}\n\nfor param in \"${!PARAM_VALUE[@]}\"; do\n        param=${param}\n        param_value=\"${PARAM_VALUE[${param}]}\"\n        log \"${param} : ${PARAM_VALUE[${param}]}\"\n        changeParameterValue \"${param}\" \"${PARAM_VALUE[${param}]}\" \"${PG_STAGED_DATA}/${TMPFILE}\"\ndone\n\n#\n# Update all the archive commands ...\n#\nsed -i '/^[[:space:]]*archive_/s/archive_/#archive_/' ${PG_STAGED_DATA}/${TMPFILE}\n\nOLD_IFS=\"$IFS\"\nIFS=$'\\n'\nfor values in $(echo ${CONFIG_PARAMS_STG} | tr \",\" \"\\n\" | sed -e 's/^ //g'); do\n        param=$(echo ${values} | awk '{print $1}')\n        log \"param : $param\"\n        #\n        # Check if the parameter provided is correct ...\n        #\n        paramCount=$(grep -w \"${param}\" ${PG_STAGED_DATA}/${TMPFILE} | wc -l)\n        if [[ ${paramCount} -gt 0 ]]; then\n                param_value=$(echo ${values} | awk '{print $2}')\n                log \"param value : $param_value\"\n                changeParameterValue \"${param}\" \"${param_value}\" \"${PG_STAGED_DATA}/${TMPFILE}\"\n        else\n                errorLog \"Parameter provided by the user does not exist in postgresql.conf file and is invalid : ${param}. Please provide the correct parameter and try again.\"\n                exitWithError ERROR invalidParamInConfigStg ${param}\n        fi\ndone\nIFS=\"$OLD_IFS\"\n\n#\n# Replace postgresql.conf file ...\n#\nmv ${PG_STAGED_DATA}/${TMPFILE} ${PG_STAGED_DATA}/postgresql.conf\nlog \"${PG_STAGED_DATA}/postgresql.conf  ...  updated\"\n\n#\n# Verify postgresql.conf file settings ...\n#\nresults=$(cat ${PG_STAGED_DATA}/postgresql.conf | grep '^port =')\nlog \"$results\"\nresults=$(cat ${PG_STAGED_DATA}/postgresql.conf | grep '^hot_standby =')\nlog \"$results\"\nresults=$(cat ${PG_STAGED_DATA}/postgresql.conf | grep '^wal_level =')\nlog \"$results\"\nresults=$(cat ${PG_STAGED_DATA}/postgresql.conf | grep '^max_wal_senders =')\nlog \"$results\"\n\n##############################################################\n#\n# Create/Modify the staging recovery.conf ...\n#\nif [[ \"${BACKUP_FLAG}\" == \"true\" ]] || [[ \"${IN_SYNC_FLAG}\" == \"true\" ]]; then\n        cat > ${PG_STAGED_DATA}/recovery.conf <<EOF\n        standby_mode = on\n        primary_conninfo = 'port=${PG_SOURCE_PORT} user=${PG_REPL_USER} password=${PG_REPL_PASS} host=${PG_SOURCE_IP}'\nEOF\n        errorCheck ERROR errorCreatingFile ${hostName}\n        log \"${PG_STAGED_DATA}/recovery.conf  ...updated\"\n\n        results=$(cat ${PG_STAGED_DATA}/recovery.conf)\n        log \"$results\"\nelse\n        if [[ \"${WAL_LOG_PATH}\" != \"\" ]]; then\n                WAL_CONTROL_SCRIPT_DIR=${PG_STAGED_DATA}/scripts\n                mkdir -p ${WAL_CONTROL_SCRIPT_DIR}\n#\n# This `walControl.sh` script will be used as an archive_command in recovery.conf file. This script will\n# help us to detect the wal log chain break and also the invalid record file. This script will be create some files as below :\n# 1 : NextExpectedFile : This file will keep the track of wal file which is expected by the database.\n# 2 : LastWalLsn : This file will check and keep the track of LSN of the last appliled wal file.\n# 3 : AppliedWalFiles : This file keeps the track of all wal files which are succesfully applied by the database.\n# 4 : WalFilesPresent : This file will keep the track of all the wal log files which are provided by the customer and is present at that time.\n# 5 : InvalidRecordFileFound : If this file is present then it indicates that invalid wal log file has been found. It also contains the name of invalid wal file.\n# 6 : WalBreakChainDetected : If this file is present then it indicates that wal log chain break has been detected. It also contatins the name file which was expected by database.\n#\ncat > ${WAL_CONTROL_SCRIPT_DIR}/walControl.sh << EOF\n#\n# archive_command script ...\n#\n\n# This function extract the LSN of incoming wal file using pgxlog_dump and keeps this record in \\'LastWalLsn'\\ file.\n# Step 1) integrity check of file is done through LSN and if it invalid then we stop the database and throw the exact error message with file name.\n# Step 2) If the file is correct then we keep the track of the correct files in AppliedWalFiles.\n# Step 3) Finally we copy the wal file into postgres transactional logs directory.\n#\nfunction walFileFound {\n        src_path=\\$1\n        dest_path=\\$2\n        wal_file=\\$(echo \\${src_path} | awk -F \"/\" '{print \\$NF}')\n\n        if [[ ! -f ${WAL_CONTROL_SCRIPT_DIR}/LastWalLsn ]]; then\n               if [[ -f ${PG_STAGED_BIN}/pg_xlogdump ]]; then\n                       ${PG_STAGED_BIN}/pg_xlogdump \\${src_path} | grep 'rmgr: XLOG' | awk -F \":\" '{print \\$5}' | awk -F\",\" '{print \\$1}' | tail -1 | sed -e 's/ //g' > ${WAL_CONTROL_SCRIPT_DIR}/LastWalLsn\n               elif [[ -f ${PG_STAGED_BIN}/pg_waldump ]]; then\n                       ${PG_STAGED_BIN}/pg_waldump \\${src_path} | grep 'rmgr: XLOG' | awk -F \":\" '{print \\$5}' | awk -F\",\" '{print \\$1}' | tail -1 | sed -e 's/ //g' > ${WAL_CONTROL_SCRIPT_DIR}/LastWalLsn\n               fi\n        else\n               if [[ -f ${PG_STAGED_BIN}/pg_xlogdump ]]; then\n                       Curr_LSN=\\$(${PG_STAGED_BIN}/pg_xlogdump \\${src_path} | grep 'prev' | awk -F \":\" '{print \\$5}' | awk -F\",\" '{print \\$2}'| awk '{print \\$2}' | head -1 | sed -e 's/ //g')\n                       Last_LSN=\\$(cat ${WAL_CONTROL_SCRIPT_DIR}/LastWalLsn)\n               elif [[ -f ${PG_STAGED_BIN}/pg_waldump ]]; then\n                       Curr_LSN=\\$(${PG_STAGED_BIN}/pg_waldump \\${src_path} | grep 'prev' | awk -F \":\" '{print \\$5}' | awk -F\",\" '{print \\$2}'| awk '{print \\$2}' | head -1 | sed -e 's/ //g')\n                       Last_LSN=\\$(cat ${WAL_CONTROL_SCRIPT_DIR}/LastWalLsn)\n               fi\n\n               if [[ \\${Curr_LSN} != \\${Last_LSN} ]]; then\n                      #\n                      # Check if wal file is already applied ...\n                      #\n                      alreadyApplied=\\$(grep \\${wal_file} ${WAL_CONTROL_SCRIPT_DIR}/AppliedWalFiles 2>/dev/null | wc -l)\n                      if [[ \\${alreadyApplied} -eq 0 ]]; then\n                              LastCheckPointRedoWal=\\$(${PG_STAGED_BIN}/pg_controldata ${PG_STAGED_DATA} | grep \"REDO WAL file\" | awk -F\":\" '{print \\$2}' | sed -e 's/ //g')\n                              if [[ \\${LastCheckPointRedoWal} != \\${wal_file} ]]; then\n                                      echo \"Invalid Record Wal File Found. Please resynchronize or provide correct Wal File. File : \\${wal_file}\" > ${WAL_CONTROL_SCRIPT_DIR}/InvalidRecordFileFound\n                                      ${PG_STAGED_BIN}/pg_ctl -D ${PG_STAGED_DATA} stop\n                              else\n                                      rm -f ${WAL_CONTROL_SCRIPT_DIR}/LastWalLsn\n                              fi\n                      fi\n               else\n                      if [[ -f ${PG_STAGED_BIN}/pg_xlogdump ]]; then\n                              ${PG_STAGED_BIN}/pg_xlogdump \\${src_path} | grep 'rmgr: XLOG' | awk -F \":\" '{print \\$5}' | awk -F\",\" '{print \\$1}' | tail -1 | sed -e 's/ //g' > ${WAL_CONTROL_SCRIPT_DIR}/LastWalLsn\n                      elif [[ -f ${PG_STAGED_BIN}/pg_waldump ]]; then\n                              ${PG_STAGED_BIN}/pg_waldump \\${src_path} | grep 'rmgr: XLOG' | awk -F \":\" '{print \\$5}' | awk -F\",\" '{print \\$1}' | tail -1 | sed -e 's/ //g' > ${WAL_CONTROL_SCRIPT_DIR}/LastWalLsn\n                      fi\n               fi\n        fi\n\n        echo \"\\${wal_file}.done\" >> ${WAL_CONTROL_SCRIPT_DIR}/AppliedWalFiles\n        cp \\${src_path} \\${dest_path}\n        walFileCopied=\\$(grep \\${wal_file} ${WAL_CONTROL_SCRIPT_DIR}/NextExpectedFile 2>/dev/null| wc -l)\n        mv \\${src_path} \\${src_path}.done\n        if [[ \\${walFileCopied} -gt 0 ]]; then\n                rm -f ${WAL_CONTROL_SCRIPT_DIR}/NextExpectedFile\n        fi\n}\n\n#\n# This function keeps the track of next file in \\`NextExpectedFile\\` which is expected by the database ...\n#\nfunction expectedWalFile {\n        src_path=\\$1\n        dest_path=\\$2\n        wal_file=\\$(echo \\$1 | awk -F \"/\" '{print \\$NF}')\n        echo \"\\${wal_file}\" >> ${WAL_CONTROL_SCRIPT_DIR}/NextExpectedFile\n}\n\n#\n# This function extracts all the files which needs to be applied\n# and which are already applied on the database in \\`WalFilesPresent\\` which is further used by\n# walLogChainBreak function ...\n#\nfunction walFilesPresent {\n        src_path=\\$1\n        dest_path=\\$2\n        src_dir=\\$(dirname \\${src_path})\n        ls -lrt \\${src_dir}/000* 2>/dev/null | grep '^-' | grep -v '.backup' | grep -v 'done' | awk '{print \\$9}'| awk -F \"/\" '{print \\$NF}' | sort | uniq > ${WAL_CONTROL_SCRIPT_DIR}/WalFilesPresent\n}\n\n#\n# This function checks for the wal Log Chain Break.\n# We check the diff of two files \\`WalFilesPresent\\` and \\`AppliedWalFiles\\` and based on the\n# output we detect if there is wal log chain break. If it is detected we create a flag file \\`WalBreakChainDetected\\`\n# which is used by other processes also ...\n#\nfunction walLogChainBreak {\n        wal_file=\\$(echo \\$1 | awk -F \"/\" '{print \\$NF}')\n        if [[ ! -f \\${1} ]]; then\n                if [[ -f ${WAL_CONTROL_SCRIPT_DIR}/AppliedWalFiles ]] && [[ -f ${WAL_CONTROL_SCRIPT_DIR}/WalFilesPresent ]]; then\n                        cat ${WAL_CONTROL_SCRIPT_DIR}/AppliedWalFiles | sort | uniq > ${WAL_CONTROL_SCRIPT_DIR}/AppliedWalFiles.sorted\n                        mv ${WAL_CONTROL_SCRIPT_DIR}/AppliedWalFiles.sorted ${WAL_CONTROL_SCRIPT_DIR}/AppliedWalFiles\n                        unappliedWal=(\\$(diff ${WAL_CONTROL_SCRIPT_DIR}/WalFilesPresent ${WAL_CONTROL_SCRIPT_DIR}/AppliedWalFiles | grep '<' | awk '{print \\$2}'))\n                        if [[ \\${#unappliedWal[@]} -eq 1 ]]; then\n                                #\n\t\t                # Check if the Log file is START WAL LOCATION file of the database ...\n\t\t                #\n                                startWalFile=\\$(grep 'START WAL LOCATION' ${WAL_CONTROL_SCRIPT_DIR}/../backup_label* | awk -F\"(\" '{print \\$2}' | awk '{print \\$2}' | sed -e 's/)//g')\n                                if [[ \"\\${startWalFile}\" = \"\\${unappliedWal[@]}\" ]]; then\n                                        src_path=\\$1\n                                        src_dir=\\$(dirname \\${src_path})\n                                        mv \\${src_dir}/\\${unappliedWal[@]} \\${src_dir}/\\${unappliedWal[@]}.done\n\t\t                else\n\t\t                        echo \"Wal Log Chain Break Detected. Please resynchronize or provide the expected Wal File. Expected File is \\${wal_file}\" > ${WAL_CONTROL_SCRIPT_DIR}/WalBreakChainDetected\n                                        ${PG_STAGED_BIN}/pg_ctl -D ${PG_STAGED_DATA} stop\n\t\t                fi\n                        elif [[ \\${#unappliedWal[@]} -gt 0 ]]; then\n                                echo \"Wal Log Chain Break Detected. Please resynchronize or provide the expected Wal File. Expected File is \\${wal_file}\" > ${WAL_CONTROL_SCRIPT_DIR}/WalBreakChainDetected\n                                ${PG_STAGED_BIN}/pg_ctl -D ${PG_STAGED_DATA} stop\n                        fi\n\n                fi\n        fi\n}\n\n#\n# Main script starts here ...\n#\nif [[ -f \\${1} ]]; then\n        rm -f ${WAL_CONTROL_SCRIPT_DIR}/WalFilesPresent 2>/dev/null\n        rm -f ${WAL_CONTROL_SCRIPT_DIR}/WalBreakChainDetected 2>/dev/null\n        rm -f ${WAL_CONTROL_SCRIPT_DIR}/InvalidRecordFileFound 2>/dev/null\n        walFileFound \\$1 \\$2\nelif [[ -f \\${1}.done ]]; then\n        mv \\${1}.done \\${1}\n        rm -f ${WAL_CONTROL_SCRIPT_DIR}/WalFilesPresent 2>/dev/null\n        rm -f ${WAL_CONTROL_SCRIPT_DIR}/WalBreakChainDetected 2>/dev/null\n        rm -f ${WAL_CONTROL_SCRIPT_DIR}/InvalidRecordFileFound 2>/dev/null\n        walFileFound \\$1 \\$2\nelse\n        expectedWalFile \\$1 \\$2\n        walCount=\\$(cat ${WAL_CONTROL_SCRIPT_DIR}/NextExpectedFile | wc -l)\n        if [[ \\${walCount} -gt 15 ]]; then\n                walFilesPresent \\$1 \\$2\n                if [[ ! -f ${WAL_CONTROL_SCRIPT_DIR}/AppliedWalFiles ]]; then\n                        touch ${WAL_CONTROL_SCRIPT_DIR}/AppliedWalFiles\n                fi\n                walLogChainBreak \\$1\n        fi\nfi\nEOF\n\n                cat > ${PG_STAGED_DATA}/recovery.conf <<EOF\n                standby_mode = on\n                restore_command = '${WAL_CONTROL_SCRIPT_DIR}/walControl.sh ${WAL_LOG_PATH}/%f %p'\nEOF\n                errorCheck ERROR errorCreatingFile ${hostName}\n                log \"${PG_STAGED_DATA}/recovery.conf  ...updated\"\n\n        else\n                cat > ${PG_STAGED_DATA}/recovery.conf <<EOF\n                standby_mode = on\nEOF\n                errorCheck ERROR errorCreatingFile ${hostName}\n                log \"${PG_STAGED_DATA}/recovery.conf  ...updated\"\n\n        fi\nfi\n\nresults=$(cat ${PG_STAGED_DATA}/recovery.conf)\nlog \"$results\"\n\n##############################################################\n#\n# Provide permissions ...\n#\nchmod 0700 ${PG_STAGED_DATA}/recovery.conf\nchmod 0700 ${PG_STAGED_DATA}\nif [[ -f ${WAL_CONTROL_SCRIPT_DIR}/walControl.sh ]]; then\n        chmod 755 ${WAL_CONTROL_SCRIPT_DIR}/walControl.sh\nfi\n\nresults=$( ls -ll ${PG_STAGED_DATA} )\nlog \"ls -ll ${PG_STAGED_DATA}\n$results\"\n\n##############################################################\n### Output\n\noutputJSON='{}'\noutputJSON=$($DLPX_BIN_JQ \".errorType = $(jqQuote \"None\")\" <<< \"$outputJSON\")\noutputJSON=$($DLPX_BIN_JQ \".messageID = $(jqQuote \"None\")\" <<< \"$outputJSON\")\noutputJSON=$($DLPX_BIN_JQ \".allParams= $(jqQuote \"None\")\" <<< \"$outputJSON\")\nlog \"Output: $outputJSON\"\nprintf \"$outputJSON\" > \"$DLPX_OUTPUT_FILE\"\n\nlog \"======================================== ${PGM_NAME} Ended ========================================\"\nexit 0\n", 
        "startStaging.sh": "#\n# Copyright (c) 2018, 2019 by Delphix. All rights reserved.\n#\n# This script is used to start the database.\n#\n\n#\n# Program Name ...\n#\nPGM_NAME='startStaging.sh'\n\n#\n# Load Library ...\n#\neval \"${DLPX_LIBRARY_SOURCE}\"\nlog \"======================================== ${PGM_NAME} Started ========================================\"\n\nhostName=$(hostname)\nlog \"Hostname: ${hostName}\"\n\nRESULTS=$( pg_portStatus \"${PG_STAGED_PORT}\" )\nlog \"Results: ${RESULTS}\"\n\nzPSID=$(echo \"${RESULTS}\" | ${DLPX_BIN_JQ} --raw-output \".processId\")\nzPSCMD=$(echo \"${RESULTS}\" | ${DLPX_BIN_JQ} --raw-output \".processCmd\")\nzDATA_DIR=$(echo \"${RESULTS}\" | ${DLPX_BIN_JQ} --raw-output \".dataDir\")\nzSTATUS=$(echo \"${RESULTS}\" | ${DLPX_BIN_JQ} --raw-output \".status\")\n\n#\n# Process Status ...\n#\nif [[ \"${zSTATUS}\" != \"ACTIVE\" ]]; then\n        NEW_DATA_DIR=\"${DLPX_DATA_DIRECTORY}/data\"\n        INSTALL_BIN=\"${PG_INSTALL_PATH}/bin\"\n        log \"CMD: pg_startDatabase \\\"${INSTALL_BIN}\\\" \\\"${NEW_DATA_DIR}\\\" \\\"${PG_STAGED_PORT}\\\" \"\n        PID=$( pg_startDatabase \"${INSTALL_BIN}\" \"${NEW_DATA_DIR}\" \"${PG_STAGED_PORT}\" )\n\n                if [[ \"${PID}\" == \"dataDirMissing\" ]]; then\n                        exitWithError ERROR dataDirMissing ${NEW_DATA_DIR}\n                elif [[ \"${PID}\" == \"installDirMissing\" ]]; then\n                        exitWithError ERROR installDirMissing \"${INSTALL_BIN}\"\n                elif [[ \"${PID}\" == \"Failed\" ]]; then\n                        if [[ ! -f ${NEW_DATA_DIR}/postmaster.pid ]]; then\n                                if [[ -f ${NEW_DATA_DIR}/scripts/WalBreakChainDetected ]]; then\n                                        ErrorCode=$(cat ${NEW_DATA_DIR}/scripts/WalBreakChainDetected)\n                                        log \"${ErrorCode}\"\n                                        exitWithError ERROR walLogChainBreakDetected \"${ErrorCode}\"\n                                elif [[ -f ${NEW_DATA_DIR}/scripts/InvalidRecordFileFound ]]; then\n                                        ErrorCode=$(cat ${NEW_DATA_DIR}/scripts/InvalidRecordFileFound)\n                                        log \"${ErrorCode}\"\n                                        exitWithError ERROR walLogChainBreakDetected \"${ErrorCode}\"\n                                fi\n\n                                if [[ -d ${NEW_DATA_DIR}/pg_log ]]; then\n                                        databaseStatus=$(validatenewTableSpace ${NEW_DATA_DIR}/pg_log)\n                                        if [[ \"${databaseStatus}\" == \"newTableSpaceFound\" ]]; then\n                                                log \"A new tablespace is created on source. Please resync dSource\"\n                                        else\n                                                log \"Database is down.\"\n                                                exitWithError ERROR dbDown ${hostName}\n                                        fi\n                                elif [[ -d ${NEW_DATA_DIR}/log ]]; then\n                                        #\n                                        # Check for EDB ...\n                                        #\n                                        databaseStatus=$(validatenewTableSpace ${NEW_DATA_DIR}/log)\n                                        if [[ \"${databaseStatus}\" == \"newTableSpaceFound\" ]]; then\n                                                log \"A new tablespace is created on source. Please resync dSource\"\n                                        else\n                                                log \"Database is down.\"\n                                                exitWithError ERROR dbDown ${hostName}\n                                        fi\n                                else\n                                        log \"Database is down.\"\n                                        exitWithError ERROR dbDown ${hostName}\n                                fi\n                        fi\n                else\n                        log \"Startup Process Id: ${PID}\"\n                fi\nelse\n        log \"Warning: Database already started on port ${PG_STAGED_PORT}\"\nfi\noutputJSON='{}'\noutputJSON=$($DLPX_BIN_JQ \".errorType = $(jqQuote \"None\")\" <<< \"$outputJSON\")\noutputJSON=$($DLPX_BIN_JQ \".messageID = $(jqQuote \"None\")\" <<< \"$outputJSON\")\noutputJSON=$($DLPX_BIN_JQ \".allParams = $(jqQuote \"None\")\" <<< \"$outputJSON\")\n\nprintf \"$outputJSON\" > \"$DLPX_OUTPUT_FILE\"\nlog \"Output : $outputJSON\"\n\nlog \"======================================== ${PGM_NAME} Ended ========================================\"\nexit 0\n", 
        "stopVirtual.sh": "#\n# Copyright (c) 2018, 2019 by Delphix. All rights reserved.\n#\n\n#\n# Program Name ...\n#\nPGM_NAME='stopVirtual.sh'\n\n#\n# Load Library ...\n#\neval \"${DLPX_LIBRARY_SOURCE}\"\nlog \"======================================== ${PGM_NAME} Started ========================================\"\n\nRESULTS=$( pg_portStatus \"${PG_VIRTUAL_PORT}\" )\nlog \"Results: ${RESULTS}\"\n\nzPSID=$(echo \"${RESULTS}\" | $DLPX_BIN_JQ --raw-output \".processId\")\nzPSCMD=$(echo \"${RESULTS}\" | $DLPX_BIN_JQ --raw-output \".processCmd\")\nzDATA_DIR=$(echo \"${RESULTS}\" | $DLPX_BIN_JQ --raw-output \".dataDir\")\nzSTATUS=$(echo \"${RESULTS}\" | $DLPX_BIN_JQ --raw-output \".status\")\n\n#\n# Process Status ...\n#\nif [[ \"${zSTATUS}\" == \"ACTIVE\" ]] && [[ \"${zDATA_DIR}\" == \"${DLPX_DATA_DIRECTORY}/data\" ]]; then\n        log \"CMD: ${zPSCMD}\"\n        pg_stopDatabase \"${zPSID}\" \"${zPSCMD}\" \"${zDATA_DIR}\" \"${PG_VIRTUAL_PORT}\"\nelse\n        log \"No process found for data directory ${DLPX_DATA_DIRECTORY}/data with port ${PG_VIRTUAL_PORT}\"\nfi\n\noutputJSON='{}'\noutputJSON=$($DLPX_BIN_JQ \".errorType = $(jqQuote \"None\")\" <<< \"$outputJSON\")\noutputJSON=$($DLPX_BIN_JQ \".messageID = $(jqQuote \"None\")\" <<< \"$outputJSON\")\noutputJSON=$($DLPX_BIN_JQ \".allParams = $(jqQuote \"None\")\" <<< \"$outputJSON\")\nlog \"Output: $outputJSON\"\nprintf \"$outputJSON\" > \"$DLPX_OUTPUT_FILE\"\n\nlog \"======================================== ${PGM_NAME} Ended ========================================\"\nexit 0\n", 
        "customConfigParam.sh": "#\n# Copyright (c) 2018, 2019 by Delphix. All rights reserved.\n#\n\n#\n# Program Name ...\n#\nPGM_NAME='customConfigParam.sh'\n\n#\n# Load Library ...\n#\neval \"${DLPX_LIBRARY_SOURCE}\"\nlog \"======================================== ${PGM_NAME} Started ========================================\"\n\nhostName=$(hostname)\nNEW_DATA_DIR=\"${DLPX_DATA_DIRECTORY}/data\"\n\nif [[ \"${PG_STAGED_PORT}\" = \"\" ]]; then\n        PORT=${PG_VIRTUAL_PORT}\nelse\n        PORT=${PG_STAGED_PORT}\nfi\n\n#\n# Update user provided configuration parameters in postgresql.conf file\n#\nOLD_IFS=\"$IFS\"\nIFS=$'\\n'\nTMPFILE=\"tmp.conf_${DT}\"\ncp ${NEW_DATA_DIR}/postgresql.conf ${NEW_DATA_DIR}/${TMPFILE}\nfor values in $(echo ${CONFIG_PARAMS_STG} | tr \",\" \"\\n\" | sed -e 's/^ //g'); do\n        param=$(echo ${values} | awk '{print $1}')\n        log \"param : $param\"\n        #\n        # Check if the parameter provided is correct ...\n        #\n        paramCount=$(grep -w \"${param}\" ${NEW_DATA_DIR}/${TMPFILE} | wc -l)\n        if [[ ${paramCount} -gt 0 ]]; then\n                param_value=$(echo ${values} | awk '{print $2}')\n                log \"param value : $param_value\"\n                changeParameterValue \"${param}\" \"${param_value}\" \"${NEW_DATA_DIR}/${TMPFILE}\"\n        else\n                errorLog \"Parameter provided by the user does not exist in postgresql.conf file and is invalid : ${param}. Please provide the correct parameter and try again.\"\n                exitWithError ERROR invalidParamInConfigStg ${param}\n        fi\ndone\nIFS=\"$OLD_IFS\"\n\n#\n# Check for port number change request ...\n#\nCURR_PORT=$(cat ${NEW_DATA_DIR}/postgresql.conf | grep -E \"^port = \" | awk -F\" = \" '{print $2}' | awk -F\" \" '{print $1}')\nif [[ \"${CURR_PORT}\" != \"${PORT}\" ]]; then\n        portStatus=$(isPortAvailable \"${PORT}\")\n\n        if [[ \"${portStatus}\" == \"PortNotAvailable\" ]]; then\n                errorLog \"Provided port : ${PORT} is already in use. Please provide a different port.\"\n                exitWithError ERROR portInUse \"${PORT}\"\n        elif [[ \"${portStatus}\" == \"InvaidPortRange\" ]]; then\n                errorLog \"Input port : ${PORT} is invalid. Please provide a valid port number.\"\n                exitWithError ERROR invalidPortRange \"${PORT}\"\n        fi\n\n        changeParameterValue \"port\" \"${PORT}\" \"${NEW_DATA_DIR}/${TMPFILE}\"\nfi\n\nmv ${NEW_DATA_DIR}/${TMPFILE} ${NEW_DATA_DIR}/postgresql.conf\noutputJSON='{}'\noutputJSON=$($DLPX_BIN_JQ \".errorType = $(jqQuote \"None\")\" <<< \"$outputJSON\")\noutputJSON=$($DLPX_BIN_JQ \".messageID = $(jqQuote \"None\")\" <<< \"$outputJSON\")\noutputJSON=$($DLPX_BIN_JQ \".allParams = $(jqQuote \"None\")\" <<< \"$outputJSON\")\n\nprintf \"$outputJSON\" > \"$DLPX_OUTPUT_FILE\"\nlog \"Output : $outputJSON\"\n\nlog \"======================================== ${PGM_NAME} Ended ========================================\"\nexit 0\n"
    }
}